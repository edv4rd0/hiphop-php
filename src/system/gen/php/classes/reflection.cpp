/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010 Facebook, Inc. (http://www.facebook.com)          |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <php/classes/exception.h>
#include <php/classes/reflection.h>
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////

/* preface starts */
/* preface finishes */
/* SRC: classes/reflection.php line 92 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionfunctionabstract
Variant c_reflectionfunctionabstract::os_getInit(const char *s, int64 hash) {
  DECLARE_SYSTEM_GLOBALS(g);
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 1:
      HASH_RETURN(0x3255DC7C4A035C47LL, 
                  null, info);
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionfunctionabstract
Variant c_reflectionfunctionabstract::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionfunctionabstract
Variant &c_reflectionfunctionabstract::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionfunctionabstract
void c_reflectionfunctionabstract::o_get(Array &props) const {
  if (isInitialized(m_info)) props.set("info", m_info.isReferenced() ? ref(m_info) : m_info, 0x3255DC7C4A035C47LL, true);
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_get_reflectionfunctionabstract
Variant c_reflectionfunctionabstract::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_reflectionfunctionabstract::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionfunctionabstract
Variant c_reflectionfunctionabstract::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 1) {
    case 1:
      HASH_RETURN_STRING(0x3255DC7C4A035C47LL, m_info,
                         info, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionfunctionabstract
Variant c_reflectionfunctionabstract::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_exists_reflectionfunctionabstract
bool c_reflectionfunctionabstract::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_reflectionfunctionabstract::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionfunctionabstract
bool c_reflectionfunctionabstract::o_existsPublic(CStrRef s, int64 hash) const {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 1) {
    case 1:
      HASH_EXISTS_STRING(0x3255DC7C4A035C47LL, info, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionfunctionabstract
bool c_reflectionfunctionabstract::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_set_reflectionfunctionabstract
Variant c_reflectionfunctionabstract::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_reflectionfunctionabstract::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionfunctionabstract
Variant c_reflectionfunctionabstract::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 1) {
    case 1:
      HASH_SET_STRING(0x3255DC7C4A035C47LL, m_info,
                      info, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionfunctionabstract
Variant c_reflectionfunctionabstract::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_lval_reflectionfunctionabstract
Variant& c_reflectionfunctionabstract::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_reflectionfunctionabstract::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionfunctionabstract
Variant& c_reflectionfunctionabstract::o_lvalPublic(CStrRef s, int64 hash) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 1) {
    case 1:
      HASH_RETURN_STRING(0x3255DC7C4A035C47LL, m_info,
                         info, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionfunctionabstract
Variant& c_reflectionfunctionabstract::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionfunctionabstract
Variant c_reflectionfunctionabstract::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionfunctionabstract
IMPLEMENT_CLASS(reflectionfunctionabstract)
ObjectData *c_reflectionfunctionabstract::cloneImpl() {
  c_reflectionfunctionabstract *obj = NEW(c_reflectionfunctionabstract)();
  cloneSet(obj);
  return obj;
}
void c_reflectionfunctionabstract::cloneSet(c_reflectionfunctionabstract *clone) {
  clone->m_info = m_info.isReferenced() ? ref(m_info) : m_info;
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionfunctionabstract
Variant c_reflectionfunctionabstract::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x57D8DC34C9A03560LL, getnumberofparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 1:
      HASH_GUARD(0x4D637DECDBFA6221LL, getnumberofrequiredparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 2:
      HASH_GUARD(0x33A6C2CFBDB05EE2LL, getclosure) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getclosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 4:
      HASH_GUARD(0x6A6B8BECAE7D4164LL, isuserdefined) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
        return (t_isuserdefined());
      }
      HASH_GUARD(0x39C1BB731CB1CB04LL, getstartline) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
        return (t_getstartline());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x37FFB8F44A3329A8LL, getstaticvariables) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
        return (t_getstaticvariables());
      }
      HASH_GUARD(0x1A3AB3B0276D2668LL, returnsreference) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
        return (t_returnsreference());
      }
      break;
    case 13:
      HASH_GUARD(0x3E62225132C2A32DLL, getparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
        return (t_getparameters());
      }
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD(0x48FDF6C5835C64CFLL, isinternal) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 16:
      HASH_GUARD(0x6C19E85007BC4570LL, getendline) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
        return (t_getendline());
      }
      break;
    case 24:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionfunctionabstract
Variant c_reflectionfunctionabstract::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x57D8DC34C9A03560LL, getnumberofparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 1:
      HASH_GUARD(0x4D637DECDBFA6221LL, getnumberofrequiredparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 2:
      HASH_GUARD(0x33A6C2CFBDB05EE2LL, getclosure) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getclosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 4:
      HASH_GUARD(0x6A6B8BECAE7D4164LL, isuserdefined) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
        return (t_isuserdefined());
      }
      HASH_GUARD(0x39C1BB731CB1CB04LL, getstartline) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
        return (t_getstartline());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x37FFB8F44A3329A8LL, getstaticvariables) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
        return (t_getstaticvariables());
      }
      HASH_GUARD(0x1A3AB3B0276D2668LL, returnsreference) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
        return (t_returnsreference());
      }
      break;
    case 13:
      HASH_GUARD(0x3E62225132C2A32DLL, getparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
        return (t_getparameters());
      }
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD(0x48FDF6C5835C64CFLL, isinternal) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 16:
      HASH_GUARD(0x6C19E85007BC4570LL, getendline) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
        return (t_getendline());
      }
      break;
    case 24:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionfunctionabstract
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionfunctionabstract
Variant c_reflectionfunctionabstract::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionfunctionabstract
Variant c_reflectionfunctionabstract::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD(0x57D8DC34C9A03560LL, getnumberofparameters) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofparameters());
      }
      break;
    case 1:
      HASH_GUARD(0x4D637DECDBFA6221LL, getnumberofrequiredparameters) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 2:
      HASH_GUARD(0x33A6C2CFBDB05EE2LL, getclosure) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getclosure", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclosure());
      }
      break;
    case 4:
      HASH_GUARD(0x6A6B8BECAE7D4164LL, isuserdefined) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isuserdefined());
      }
      HASH_GUARD(0x39C1BB731CB1CB04LL, getstartline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstartline());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x37FFB8F44A3329A8LL, getstaticvariables) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstaticvariables());
      }
      HASH_GUARD(0x1A3AB3B0276D2668LL, returnsreference) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_returnsreference());
      }
      break;
    case 13:
      HASH_GUARD(0x3E62225132C2A32DLL, getparameters) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getparameters());
      }
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD(0x48FDF6C5835C64CFLL, isinternal) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinternal());
      }
      break;
    case 16:
      HASH_GUARD(0x6C19E85007BC4570LL, getendline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getendline());
      }
      break;
    case 24:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_reflectionfunctionabstract::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_reflectionfunctionabstract = {
  c_reflectionfunctionabstract::os_getInit,
  c_reflectionfunctionabstract::os_get,
  c_reflectionfunctionabstract::os_lval,
  c_reflectionfunctionabstract::os_invoke,
  c_reflectionfunctionabstract::os_constant,
};
void c_reflectionfunctionabstract::init() {
  m_info = null;
}
/* SRC: classes/reflection.php line 95 */
Variant c_reflectionfunctionabstract::t_getname() {
  INSTANCE_METHOD_INJECTION(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getName);
  return m_info.rvalAt("name", 0x0BCDB293DC3DBDDCLL, true, true);
} /* function */
/* SRC: classes/reflection.php line 99 */
Variant c_reflectionfunctionabstract::t_isinternal() {
  INSTANCE_METHOD_INJECTION(ReflectionFunctionAbstract, ReflectionFunctionAbstract::isInternal);
  return m_info.rvalAt("internal", 0x575D95D69333A8ACLL, true, true);
} /* function */
/* SRC: classes/reflection.php line 103 */
Variant c_reflectionfunctionabstract::t_getclosure() {
  INSTANCE_METHOD_INJECTION(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getClosure);
  return m_info.rvalAt("closure", 0x3828EA96366C415ALL, true, true);
} /* function */
/* SRC: classes/reflection.php line 107 */
bool c_reflectionfunctionabstract::t_isuserdefined() {
  INSTANCE_METHOD_INJECTION(ReflectionFunctionAbstract, ReflectionFunctionAbstract::isUserDefined);
  return !(toBoolean(m_info.rvalAt("internal", 0x575D95D69333A8ACLL, true, true)));
} /* function */
/* SRC: classes/reflection.php line 111 */
Variant c_reflectionfunctionabstract::t_getfilename() {
  INSTANCE_METHOD_INJECTION(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getFileName);
  return m_info.rvalAt("file", 0x08C19339767C0884LL, true, true);
} /* function */
/* SRC: classes/reflection.php line 115 */
Variant c_reflectionfunctionabstract::t_getstartline() {
  INSTANCE_METHOD_INJECTION(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getStartLine);
  return m_info.rvalAt("line1", 0x7E7BD613D4C67725LL, true, true);
} /* function */
/* SRC: classes/reflection.php line 119 */
Variant c_reflectionfunctionabstract::t_getendline() {
  INSTANCE_METHOD_INJECTION(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getEndLine);
  return m_info.rvalAt("line2", 0x641B12C5BEFE32A8LL, true, true);
} /* function */
/* SRC: classes/reflection.php line 123 */
Variant c_reflectionfunctionabstract::t_getdoccomment() {
  INSTANCE_METHOD_INJECTION(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getDocComment);
  return m_info.rvalAt("doc", 0x3E08E8478690475CLL, true, true);
} /* function */
/* SRC: classes/reflection.php line 127 */
Variant c_reflectionfunctionabstract::t_getstaticvariables() {
  INSTANCE_METHOD_INJECTION(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getStaticVariables);
  return m_info.rvalAt("static_variables", 0x4BC9448B5BE6A94ALL, true, true);
} /* function */
/* SRC: classes/reflection.php line 131 */
Variant c_reflectionfunctionabstract::t_returnsreference() {
  INSTANCE_METHOD_INJECTION(ReflectionFunctionAbstract, ReflectionFunctionAbstract::returnsReference);
  return m_info.rvalAt("ref", 0x0B1A6D25134ED5FALL, true, true);
} /* function */
/* SRC: classes/reflection.php line 135 */
Array c_reflectionfunctionabstract::t_getparameters() {
  INSTANCE_METHOD_INJECTION(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getParameters);
  Array v_ret;
  Primitive v_name = 0;
  Variant v_info;
  p_reflectionparameter v_param;

  (v_ret = SystemScalarArrays::ssa_[0]);
  {
    LOOP_COUNTER(1);
    Variant map2 = m_info.rvalAt("params", 0x6E4C9E151F21AC62LL, true, true);
    for (ArrayIterPtr iter3 = map2.begin("reflectionfunctionabstract"); !iter3->end(); iter3->next()) {
      LOOP_COUNTER_CHECK(1);
      iter3->second(v_info);
      v_name = iter3->first();
      {
        {
          p_reflectionparameter tmp4((p_reflectionparameter((NEWOBJ(c_reflectionparameter)())->create(null, null))));
          (v_param = tmp4);
        }
        (AS_CLASS(v_param,c_reflectionparameter)->m_info = v_info);
        v_ret.append((v_param));
      }
    }
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 145 */
int c_reflectionfunctionabstract::t_getnumberofparameters() {
  INSTANCE_METHOD_INJECTION(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getNumberOfParameters);
  return x_count(m_info.rvalAt("params", 0x6E4C9E151F21AC62LL, true, true));
} /* function */
/* SRC: classes/reflection.php line 149 */
int64 c_reflectionfunctionabstract::t_getnumberofrequiredparameters() {
  INSTANCE_METHOD_INJECTION(ReflectionFunctionAbstract, ReflectionFunctionAbstract::getNumberOfRequiredParameters);
  int64 v_count = 0;
  Array v_params;
  Primitive v_name = 0;
  Variant v_param;

  (v_count = 0LL);
  {
    Array tmp5((t_getparameters()));
    (v_params = tmp5);
  }
  {
    LOOP_COUNTER(6);
    for (ArrayIter iter8 = v_params.begin("reflectionfunctionabstract"); !iter8.end(); ++iter8) {
      LOOP_COUNTER_CHECK(6);
      iter8.second(v_param);
      v_name = iter8.first();
      {
        if (toBoolean(v_param. BIND_CLASS_DOT o_invoke_few_args("isOptional", 0x2D6EF48BBAB22735LL, 0))) {
          {
            break;
          }
        }
        v_count++;
      }
    }
  }
  return v_count;
} /* function */
/* SRC: classes/reflection.php line 520 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionobject
Variant c_reflectionobject::os_getInit(const char *s, int64 hash) {
  return c_reflectionclass::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionobject
Variant c_reflectionobject::os_get(const char *s, int64 hash) {
  return c_reflectionclass::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionobject
Variant &c_reflectionobject::os_lval(const char *s, int64 hash) {
  return c_reflectionclass::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionobject
void c_reflectionobject::o_get(Array &props) const {
  c_reflectionclass::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_get_reflectionobject
Variant c_reflectionobject::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  const char *s = context;
  if (!s) { context = s = FrameInjection::GetClassName(false); }
  int64 hash = hash_string_i(s);
  switch (hash & 1) {
    case 1:
      HASH_GUARD(0x35A44A5E6AE2E71DLL, reflectionclass) { return c_reflectionclass::o_getPrivate(prop, phash, error); }
      break;
    default:
      break;
  }
  return c_reflectionobject::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionobject
Variant c_reflectionobject::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_reflectionclass::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionobject
Variant c_reflectionobject::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_exists_reflectionobject
bool c_reflectionobject::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  const char *s = context;
  if (!s) { context = s = FrameInjection::GetClassName(false); }
  int64 hash = hash_string_i(s);
  switch (hash & 1) {
    case 1:
      HASH_GUARD(0x35A44A5E6AE2E71DLL, reflectionclass) { return c_reflectionclass::o_existsPrivate(prop, phash); }
      break;
    default:
      break;
  }
  return c_reflectionobject::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionobject
bool c_reflectionobject::o_existsPublic(CStrRef s, int64 hash) const {
  return c_reflectionclass::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionobject
bool c_reflectionobject::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_set_reflectionobject
Variant c_reflectionobject::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  const char *s = context;
  if (!s) { context = s = FrameInjection::GetClassName(false); }
  int64 hash = hash_string_i(s);
  switch (hash & 1) {
    case 1:
      HASH_GUARD(0x35A44A5E6AE2E71DLL, reflectionclass) { return c_reflectionclass::o_setPrivate(prop, phash, v, forInit); }
      break;
    default:
      break;
  }
  return c_reflectionobject::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionobject
Variant c_reflectionobject::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_reflectionclass::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionobject
Variant c_reflectionobject::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_lval_reflectionobject
Variant& c_reflectionobject::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  const char *s = context;
  if (!s) { context = s = FrameInjection::GetClassName(false); }
  int64 hash = hash_string_i(s);
  switch (hash & 1) {
    case 1:
      HASH_GUARD(0x35A44A5E6AE2E71DLL, reflectionclass) { return c_reflectionclass::o_lvalPrivate(prop, phash); }
      break;
    default:
      break;
  }
  return c_reflectionobject::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionobject
Variant& c_reflectionobject::o_lvalPublic(CStrRef s, int64 hash) {
  return c_reflectionclass::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionobject
Variant& c_reflectionobject::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionobject
Variant c_reflectionobject::os_constant(const char *s) {
  return c_reflectionclass::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionobject
IMPLEMENT_CLASS(reflectionobject)
ObjectData *c_reflectionobject::cloneImpl() {
  c_reflectionobject *obj = NEW(c_reflectionobject)();
  cloneSet(obj);
  return obj;
}
void c_reflectionobject::cloneSet(c_reflectionobject *clone) {
  c_reflectionclass::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionobject
Variant c_reflectionobject::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 127) {
    case 4:
      HASH_GUARD(0x39C1BB731CB1CB04LL, getstartline) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getstartline", 0, 1);
        return (t_getstartline());
      }
      break;
    case 15:
      HASH_GUARD(0x40C7B30DCB439C8FLL, hasproperty) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasproperty", count, 1, 1, 1);
        return (t_hasproperty(params[0]));
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x24253EBA491D6014LL, getmodifiers) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getmodifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 24:
      HASH_GUARD(0x21820E7AA4733998LL, hasmethod) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasmethod", count, 1, 1, 1);
        return (t_hasmethod(params[0]));
      }
      break;
    case 27:
      HASH_GUARD(0x0F1AD0A8EC4C229BLL, getdefaultproperties) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getdefaultproperties", 0, 1);
        return (t_getdefaultproperties());
      }
      break;
    case 30:
      HASH_GUARD(0x1BC5F3D87676509ELL, isinterface) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinterface", 0, 1);
        return (t_isinterface());
      }
      break;
    case 34:
      HASH_GUARD(0x323D9BCB05797B22LL, getstaticproperties) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getstaticproperties", 0, 1);
        return (t_getstaticproperties());
      }
      break;
    case 41:
      HASH_GUARD(0x030CE1D6142F8C29LL, isinstance) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::isinstance", count, 1, 1, 1);
        return (t_isinstance(params[0]));
      }
      HASH_GUARD(0x1D6B8CA358B49929LL, getextensionname) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getextensionname", 0, 1);
        return (t_getextensionname());
      }
      break;
    case 42:
      HASH_GUARD(0x16BA16CE6488AAAALL, getmethods) {
        if (count > 1) return throw_toomany_arguments("reflectionclass::getmethods", 1, 1);
        if (count <= 0) return (t_getmethods());
        return (t_getmethods(params[0]));
      }
      HASH_GUARD(0x226F6E80CECD3CAALL, getconstructor) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstructor", 0, 1);
        return (t_getconstructor());
      }
      HASH_GUARD(0x24596BE6D21F7CAALL, getinterfacenames) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfacenames", 0, 1);
        return (t_getinterfacenames());
      }
      break;
    case 46:
      HASH_GUARD(0x3C882D4A895F612ELL, getstaticpropertyvalue) {
        if (count < 1 || count > 2) return throw_wrong_arguments("reflectionclass::getstaticpropertyvalue", count, 1, 2, 1);
        if (count <= 1) return (t_getstaticpropertyvalue(params[0]));
        return (t_getstaticpropertyvalue(params[0], params[1]));
      }
      HASH_GUARD(0x06FB6A7DC3D795AELL, isfinal) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isfinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 48:
      HASH_GUARD(0x30A86FCA01FE7030LL, newinstance) {
        if (count <= 0) return (t_newinstance(count));
        return (t_newinstance(count,params.slice(0, count - 0, false)));
      }
      break;
    case 52:
      HASH_GUARD(0x3DB53E1FBD3C0734LL, getconstant) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::getconstant", count, 1, 1, 1);
        return (t_getconstant(params[0]));
      }
      break;
    case 54:
      HASH_GUARD(0x0D81ECE253A3B5B6LL, getmethod) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::getmethod", count, 1, 1, 1);
        return (t_getmethod(params[0]));
      }
      break;
    case 55:
      HASH_GUARD(0x7460D945DA32FDB7LL, isabstract) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isabstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 59:
      HASH_GUARD(0x25D24435915E6E3BLL, getextension) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getextension", 0, 1);
        return (t_getextension());
      }
      break;
    case 60:
      HASH_GUARD(0x0D8AAD6BA2BBCD3CLL, isinstantiable) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinstantiable", 0, 1);
        return (t_isinstantiable());
      }
      break;
    case 63:
      HASH_GUARD(0x54C2DC04C4A62B3FLL, hasconstant) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasconstant", count, 1, 1, 1);
        return (t_hasconstant(params[0]));
      }
      break;
    case 67:
      HASH_GUARD(0x67C15E3D98C00B43LL, getinterfaces) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfaces", 0, 1);
        return (t_getinterfaces());
      }
      break;
    case 68:
      HASH_GUARD(0x1EB679C3602F4B44LL, getproperties) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getproperties", 0, 1);
        return (t_getproperties());
      }
      break;
    case 71:
      HASH_GUARD(0x0FD73627FB023047LL, getproperty) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::getproperty", count, 1, 1, 1);
        return (t_getproperty(params[0]));
      }
      break;
    case 77:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getfilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD(0x7D5A57B5370B68CELL, isiterateable) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isiterateable", 0, 1);
        return (t_isiterateable());
      }
      break;
    case 79:
      HASH_GUARD(0x48FDF6C5835C64CFLL, isinternal) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 85:
      HASH_GUARD(0x1CC71CB013143955LL, getconstants) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::__construct", count, 1, 1, 2);
        return (t___construct(params[0]), null);
      }
      break;
    case 100:
      HASH_GUARD(0x6A6B8BECAE7D4164LL, isuserdefined) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isuserdefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 101:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getname", 0, 1);
        return (t_getname());
      }
      break;
    case 102:
      HASH_GUARD(0x2735DCC254EE5C66LL, newinstanceargs) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::newinstanceargs", count, 1, 1, 1);
        return (t_newinstanceargs(params[0]));
      }
      break;
    case 104:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 2) return throw_wrong_arguments("reflectionobject::export", count, 2, 2, 1);
        return (ti_export(o_getClassName(), params[0], params[1]));
      }
      break;
    case 112:
      HASH_GUARD(0x6C19E85007BC4570LL, getendline) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getendline", 0, 1);
        return (t_getendline());
      }
      break;
    case 113:
      HASH_GUARD(0x07ECA928E37717F1LL, setstaticpropertyvalue) {
        if (count != 2) return throw_wrong_arguments("reflectionclass::setstaticpropertyvalue", count, 2, 2, 1);
        return (t_setstaticpropertyvalue(params[0], params[1]), null);
      }
      break;
    case 114:
      HASH_GUARD(0x74F7FEDE16957472LL, getparentclass) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getparentclass", 0, 1);
        return (t_getparentclass());
      }
      break;
    case 120:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getdoccomment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 123:
      HASH_GUARD(0x28DC702215C7D6FBLL, implementsinterface) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::implementsinterface", count, 1, 1, 1);
        return (t_implementsinterface(params[0]));
      }
      break;
    case 126:
      HASH_GUARD(0x373333991926C97ELL, issubclassof) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::issubclassof", count, 1, 1, 1);
        return (t_issubclassof(params[0]));
      }
      break;
    default:
      break;
  }
  return c_reflectionclass::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionobject
Variant c_reflectionobject::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 127) {
    case 4:
      HASH_GUARD(0x39C1BB731CB1CB04LL, getstartline) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getstartline", 0, 1);
        return (t_getstartline());
      }
      break;
    case 15:
      HASH_GUARD(0x40C7B30DCB439C8FLL, hasproperty) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasproperty", count, 1, 1, 1);
        return (t_hasproperty(a0));
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x24253EBA491D6014LL, getmodifiers) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getmodifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 24:
      HASH_GUARD(0x21820E7AA4733998LL, hasmethod) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasmethod", count, 1, 1, 1);
        return (t_hasmethod(a0));
      }
      break;
    case 27:
      HASH_GUARD(0x0F1AD0A8EC4C229BLL, getdefaultproperties) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getdefaultproperties", 0, 1);
        return (t_getdefaultproperties());
      }
      break;
    case 30:
      HASH_GUARD(0x1BC5F3D87676509ELL, isinterface) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinterface", 0, 1);
        return (t_isinterface());
      }
      break;
    case 34:
      HASH_GUARD(0x323D9BCB05797B22LL, getstaticproperties) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getstaticproperties", 0, 1);
        return (t_getstaticproperties());
      }
      break;
    case 41:
      HASH_GUARD(0x030CE1D6142F8C29LL, isinstance) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::isinstance", count, 1, 1, 1);
        return (t_isinstance(a0));
      }
      HASH_GUARD(0x1D6B8CA358B49929LL, getextensionname) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getextensionname", 0, 1);
        return (t_getextensionname());
      }
      break;
    case 42:
      HASH_GUARD(0x16BA16CE6488AAAALL, getmethods) {
        if (count > 1) return throw_toomany_arguments("reflectionclass::getmethods", 1, 1);
        if (count <= 0) return (t_getmethods());
        return (t_getmethods(a0));
      }
      HASH_GUARD(0x226F6E80CECD3CAALL, getconstructor) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstructor", 0, 1);
        return (t_getconstructor());
      }
      HASH_GUARD(0x24596BE6D21F7CAALL, getinterfacenames) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfacenames", 0, 1);
        return (t_getinterfacenames());
      }
      break;
    case 46:
      HASH_GUARD(0x3C882D4A895F612ELL, getstaticpropertyvalue) {
        if (count < 1 || count > 2) return throw_wrong_arguments("reflectionclass::getstaticpropertyvalue", count, 1, 2, 1);
        if (count <= 1) return (t_getstaticpropertyvalue(a0));
        return (t_getstaticpropertyvalue(a0, a1));
      }
      HASH_GUARD(0x06FB6A7DC3D795AELL, isfinal) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isfinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 48:
      HASH_GUARD(0x30A86FCA01FE7030LL, newinstance) {
        if (count <= 0) return (t_newinstance(count));
        Array params;
        if (count >= 1) params.append(a0);
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_newinstance(count,params));
      }
      break;
    case 52:
      HASH_GUARD(0x3DB53E1FBD3C0734LL, getconstant) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::getconstant", count, 1, 1, 1);
        return (t_getconstant(a0));
      }
      break;
    case 54:
      HASH_GUARD(0x0D81ECE253A3B5B6LL, getmethod) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::getmethod", count, 1, 1, 1);
        return (t_getmethod(a0));
      }
      break;
    case 55:
      HASH_GUARD(0x7460D945DA32FDB7LL, isabstract) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isabstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 59:
      HASH_GUARD(0x25D24435915E6E3BLL, getextension) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getextension", 0, 1);
        return (t_getextension());
      }
      break;
    case 60:
      HASH_GUARD(0x0D8AAD6BA2BBCD3CLL, isinstantiable) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinstantiable", 0, 1);
        return (t_isinstantiable());
      }
      break;
    case 63:
      HASH_GUARD(0x54C2DC04C4A62B3FLL, hasconstant) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasconstant", count, 1, 1, 1);
        return (t_hasconstant(a0));
      }
      break;
    case 67:
      HASH_GUARD(0x67C15E3D98C00B43LL, getinterfaces) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfaces", 0, 1);
        return (t_getinterfaces());
      }
      break;
    case 68:
      HASH_GUARD(0x1EB679C3602F4B44LL, getproperties) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getproperties", 0, 1);
        return (t_getproperties());
      }
      break;
    case 71:
      HASH_GUARD(0x0FD73627FB023047LL, getproperty) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::getproperty", count, 1, 1, 1);
        return (t_getproperty(a0));
      }
      break;
    case 77:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getfilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD(0x7D5A57B5370B68CELL, isiterateable) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isiterateable", 0, 1);
        return (t_isiterateable());
      }
      break;
    case 79:
      HASH_GUARD(0x48FDF6C5835C64CFLL, isinternal) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 85:
      HASH_GUARD(0x1CC71CB013143955LL, getconstants) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::__construct", count, 1, 1, 2);
        return (t___construct(a0), null);
      }
      break;
    case 100:
      HASH_GUARD(0x6A6B8BECAE7D4164LL, isuserdefined) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isuserdefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 101:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getname", 0, 1);
        return (t_getname());
      }
      break;
    case 102:
      HASH_GUARD(0x2735DCC254EE5C66LL, newinstanceargs) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::newinstanceargs", count, 1, 1, 1);
        return (t_newinstanceargs(a0));
      }
      break;
    case 104:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 2) return throw_wrong_arguments("reflectionobject::export", count, 2, 2, 1);
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 112:
      HASH_GUARD(0x6C19E85007BC4570LL, getendline) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getendline", 0, 1);
        return (t_getendline());
      }
      break;
    case 113:
      HASH_GUARD(0x07ECA928E37717F1LL, setstaticpropertyvalue) {
        if (count != 2) return throw_wrong_arguments("reflectionclass::setstaticpropertyvalue", count, 2, 2, 1);
        return (t_setstaticpropertyvalue(a0, a1), null);
      }
      break;
    case 114:
      HASH_GUARD(0x74F7FEDE16957472LL, getparentclass) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getparentclass", 0, 1);
        return (t_getparentclass());
      }
      break;
    case 120:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getdoccomment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 123:
      HASH_GUARD(0x28DC702215C7D6FBLL, implementsinterface) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::implementsinterface", count, 1, 1, 1);
        return (t_implementsinterface(a0));
      }
      break;
    case 126:
      HASH_GUARD(0x373333991926C97ELL, issubclassof) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::issubclassof", count, 1, 1, 1);
        return (t_issubclassof(a0));
      }
      break;
    default:
      break;
  }
  return c_reflectionclass::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionobject
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionobject
Variant c_reflectionobject::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 2) return throw_wrong_arguments("reflectionobject::export", count, 2, 2, 1);
        return (ti_export(c, params[0], params[1]));
      }
      break;
    default:
      break;
  }
  return c_reflectionclass::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionobject
Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 127) {
    case 4:
      HASH_GUARD(0x39C1BB731CB1CB04LL, getstartline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getstartline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstartline());
      }
      break;
    case 15:
      HASH_GUARD(0x40C7B30DCB439C8FLL, hasproperty) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasproperty", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasproperty(a0));
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x24253EBA491D6014LL, getmodifiers) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getmodifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmodifiers());
      }
      break;
    case 24:
      HASH_GUARD(0x21820E7AA4733998LL, hasmethod) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasmethod", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasmethod(a0));
      }
      break;
    case 27:
      HASH_GUARD(0x0F1AD0A8EC4C229BLL, getdefaultproperties) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getdefaultproperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdefaultproperties());
      }
      break;
    case 30:
      HASH_GUARD(0x1BC5F3D87676509ELL, isinterface) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinterface", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinterface());
      }
      break;
    case 34:
      HASH_GUARD(0x323D9BCB05797B22LL, getstaticproperties) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getstaticproperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstaticproperties());
      }
      break;
    case 41:
      HASH_GUARD(0x030CE1D6142F8C29LL, isinstance) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::isinstance", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinstance(a0));
      }
      HASH_GUARD(0x1D6B8CA358B49929LL, getextensionname) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getextensionname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getextensionname());
      }
      break;
    case 42:
      HASH_GUARD(0x16BA16CE6488AAAALL, getmethods) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("reflectionclass::getmethods", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getmethods());
        else return (t_getmethods(a0));
      }
      HASH_GUARD(0x226F6E80CECD3CAALL, getconstructor) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstructor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstructor());
      }
      HASH_GUARD(0x24596BE6D21F7CAALL, getinterfacenames) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfacenames", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinterfacenames());
      }
      break;
    case 46:
      HASH_GUARD(0x3C882D4A895F612ELL, getstaticpropertyvalue) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("reflectionclass::getstaticpropertyvalue", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_getstaticpropertyvalue(a0));
        else return (t_getstaticpropertyvalue(a0, a1));
      }
      HASH_GUARD(0x06FB6A7DC3D795AELL, isfinal) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::isfinal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isfinal());
      }
      break;
    case 48:
      HASH_GUARD(0x30A86FCA01FE7030LL, newinstance) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 0) return (t_newinstance(count));
        return (t_newinstance(count,vargs));
      }
      break;
    case 52:
      HASH_GUARD(0x3DB53E1FBD3C0734LL, getconstant) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::getconstant", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstant(a0));
      }
      break;
    case 54:
      HASH_GUARD(0x0D81ECE253A3B5B6LL, getmethod) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::getmethod", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmethod(a0));
      }
      break;
    case 55:
      HASH_GUARD(0x7460D945DA32FDB7LL, isabstract) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::isabstract", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isabstract());
      }
      break;
    case 59:
      HASH_GUARD(0x25D24435915E6E3BLL, getextension) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getextension", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getextension());
      }
      break;
    case 60:
      HASH_GUARD(0x0D8AAD6BA2BBCD3CLL, isinstantiable) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinstantiable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinstantiable());
      }
      break;
    case 63:
      HASH_GUARD(0x54C2DC04C4A62B3FLL, hasconstant) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasconstant", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasconstant(a0));
      }
      break;
    case 67:
      HASH_GUARD(0x67C15E3D98C00B43LL, getinterfaces) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfaces", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinterfaces());
      }
      break;
    case 68:
      HASH_GUARD(0x1EB679C3602F4B44LL, getproperties) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getproperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getproperties());
      }
      break;
    case 71:
      HASH_GUARD(0x0FD73627FB023047LL, getproperty) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::getproperty", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getproperty(a0));
      }
      break;
    case 77:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getfilename", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD(0x7D5A57B5370B68CELL, isiterateable) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::isiterateable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isiterateable());
      }
      break;
    case 79:
      HASH_GUARD(0x48FDF6C5835C64CFLL, isinternal) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinternal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinternal());
      }
      break;
    case 85:
      HASH_GUARD(0x1CC71CB013143955LL, getconstants) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstants", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstants());
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::__construct", count, 1, 1, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 100:
      HASH_GUARD(0x6A6B8BECAE7D4164LL, isuserdefined) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::isuserdefined", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isuserdefined());
      }
      break;
    case 101:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 102:
      HASH_GUARD(0x2735DCC254EE5C66LL, newinstanceargs) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::newinstanceargs", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_newinstanceargs(a0));
      }
      break;
    case 104:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("reflectionobject::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 112:
      HASH_GUARD(0x6C19E85007BC4570LL, getendline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getendline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getendline());
      }
      break;
    case 113:
      HASH_GUARD(0x07ECA928E37717F1LL, setstaticpropertyvalue) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("reflectionclass::setstaticpropertyvalue", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setstaticpropertyvalue(a0, a1), null);
      }
      break;
    case 114:
      HASH_GUARD(0x74F7FEDE16957472LL, getparentclass) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getparentclass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getparentclass());
      }
      break;
    case 120:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getdoccomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    case 123:
      HASH_GUARD(0x28DC702215C7D6FBLL, implementsinterface) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::implementsinterface", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_implementsinterface(a0));
      }
      break;
    case 126:
      HASH_GUARD(0x373333991926C97ELL, issubclassof) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::issubclassof", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issubclassof(a0));
      }
      break;
    default:
      break;
  }
  return c_reflectionclass::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_reflectionobject::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("reflectionobject::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1));
      }
      break;
    default:
      break;
  }
  return c_reflectionclass::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_reflectionobject = {
  c_reflectionobject::os_getInit,
  c_reflectionobject::os_get,
  c_reflectionobject::os_lval,
  c_reflectionobject::os_invoke,
  c_reflectionobject::os_constant,
};
void c_reflectionobject::init() {
  c_reflectionclass::init();
}
/* SRC: classes/reflection.php line 521 */
Variant c_reflectionobject::ti_export(const char* cls, Variant v_obj, CVarRef v_ret) {
  STATIC_METHOD_INJECTION(ReflectionObject, ReflectionObject::export);
  String v_str;

  {
    c_reflectionobject *tmp9 = NEWOBJ(c_reflectionobject)();
    p_reflectionobject tmp10((p_reflectionobject(tmp9->create(v_obj))));
    (v_obj = tmp10);
  }
  (v_str = (toString(v_obj)));
  if (toBoolean(v_ret)) {
    {
      return v_str;
    }
  }
  print(v_str);
  return null;
} /* function */
/* SRC: classes/reflection.php line 11 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionexception
Variant c_reflectionexception::os_getInit(const char *s, int64 hash) {
  return c_exception::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionexception
Variant c_reflectionexception::os_get(const char *s, int64 hash) {
  return c_exception::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionexception
Variant &c_reflectionexception::os_lval(const char *s, int64 hash) {
  return c_exception::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionexception
void c_reflectionexception::o_get(Array &props) const {
  c_exception::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_reflectionexception
Variant c_reflectionexception::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_reflectionexception::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionexception
Variant c_reflectionexception::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_exception::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionexception
Variant c_reflectionexception::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_reflectionexception
bool c_reflectionexception::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_reflectionexception::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionexception
bool c_reflectionexception::o_existsPublic(CStrRef s, int64 hash) const {
  return c_exception::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionexception
bool c_reflectionexception::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_reflectionexception
Variant c_reflectionexception::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_reflectionexception::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionexception
Variant c_reflectionexception::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_exception::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionexception
Variant c_reflectionexception::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_reflectionexception
Variant& c_reflectionexception::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_reflectionexception::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionexception
Variant& c_reflectionexception::o_lvalPublic(CStrRef s, int64 hash) {
  return c_exception::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionexception
Variant& c_reflectionexception::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionexception
Variant c_reflectionexception::os_constant(const char *s) {
  return c_exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionexception
IMPLEMENT_CLASS(reflectionexception)
ObjectData *c_reflectionexception::cloneImpl() {
  c_reflectionexception *obj = NEW(c_reflectionexception)();
  cloneSet(obj);
  return obj;
}
void c_reflectionexception::cloneSet(c_reflectionexception *clone) {
  c_exception::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionexception
Variant c_reflectionexception::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 2:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 3:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 14:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(params[0]), null);
        return (t___construct(params[0], params[1]), null);
      }
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    default:
      break;
  }
  return c_exception::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionexception
Variant c_reflectionexception::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 2:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        return (t_getmessage());
      }
      break;
    case 3:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        return (t_gettraceasstring());
      }
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        return (t_gettrace());
      }
      break;
    case 14:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        return (t_getfile());
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        if (count <= 0) return (t___construct(), null);
        if (count == 1) return (t___construct(a0), null);
        return (t___construct(a0, a1), null);
      }
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        return (t_getcode());
      }
      break;
    default:
      break;
  }
  return c_exception::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionexception
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionexception
Variant c_reflectionexception::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  return c_exception::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionexception
Variant c_reflectionexception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 15) {
    case 2:
      HASH_GUARD(0x71859D7313E682D2LL, getmessage) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmessage());
      }
      break;
    case 3:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      HASH_GUARD(0x31D981FD9D2728E3LL, getline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getline());
      }
      break;
    case 10:
      HASH_GUARD(0x03CA4360169ECC8ALL, gettraceasstring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettraceasstring());
      }
      HASH_GUARD(0x6800B2B4C4EC4CBALL, gettrace) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettrace());
      }
      break;
    case 14:
      HASH_GUARD(0x3CE90CB8F0C9579ELL, getfile) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfile());
      }
      break;
    case 15:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      HASH_GUARD(0x5C108B351DC3D04FLL, getcode) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcode());
      }
      break;
    default:
      break;
  }
  return c_exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_reflectionexception::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_reflectionexception = {
  c_reflectionexception::os_getInit,
  c_reflectionexception::os_get,
  c_reflectionexception::os_lval,
  c_reflectionexception::os_invoke,
  c_reflectionexception::os_constant,
};
void c_reflectionexception::init() {
  c_exception::init();
}
/* SRC: classes/reflection.php line 202 */
const int64 q_reflectionclass_IS_IMPLICIT_ABSTRACT = 16LL;
const int64 q_reflectionclass_IS_EXPLICIT_ABSTRACT = 32LL;
const int64 q_reflectionclass_IS_FINAL = 64LL;
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionclass
Variant c_reflectionclass::os_getInit(const char *s, int64 hash) {
  DECLARE_SYSTEM_GLOBALS(g);
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 0:
      HASH_RETURN(0x0BCDB293DC3DBDDCLL, 
                  null, name);
      break;
    case 3:
      HASH_RETURN(0x3255DC7C4A035C47LL, 
                  null, info);
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionclass
Variant c_reflectionclass::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionclass
Variant &c_reflectionclass::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionclass
void c_reflectionclass::o_get(Array &props) const {
  if (isInitialized(m_name)) props.set("name", m_name.isReferenced() ? ref(m_name) : m_name, 0x0BCDB293DC3DBDDCLL, true);
  if (isInitialized(m_info)) props.set(String("\0reflectionclass\0info", 21, CopyString), m_info.isReferenced() ? ref(m_info) : m_info, 0x76CD1386A6B652C3LL, true);
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_get_reflectionclass
Variant c_reflectionclass::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  const char *s = context;
  if (!s) { context = s = FrameInjection::GetClassName(false); }
  int64 hash = hash_string_i(s);
  switch (hash & 1) {
    case 1:
      HASH_GUARD(0x35A44A5E6AE2E71DLL, reflectionclass) { return o_getPrivate(prop, phash, error); }
      break;
    default:
      break;
  }
  return c_reflectionclass::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionclass
Variant c_reflectionclass::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 1) {
    case 0:
      HASH_RETURN_STRING(0x0BCDB293DC3DBDDCLL, m_name,
                         name, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionclass
Variant c_reflectionclass::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 1) {
    case 1:
      HASH_RETURN_STRING(0x3255DC7C4A035C47LL, m_info,
                         info, 4);
      break;
    default:
      break;
  }
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_exists_reflectionclass
bool c_reflectionclass::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  const char *s = context;
  if (!s) { context = s = FrameInjection::GetClassName(false); }
  int64 hash = hash_string_i(s);
  switch (hash & 1) {
    case 1:
      HASH_GUARD(0x35A44A5E6AE2E71DLL, reflectionclass) { return o_existsPrivate(prop, phash); }
      break;
    default:
      break;
  }
  return c_reflectionclass::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionclass
bool c_reflectionclass::o_existsPublic(CStrRef s, int64 hash) const {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 1) {
    case 0:
      HASH_EXISTS_STRING(0x0BCDB293DC3DBDDCLL, name, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionclass
bool c_reflectionclass::o_existsPrivate(CStrRef s, int64 hash) const {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 1) {
    case 1:
      HASH_EXISTS_STRING(0x3255DC7C4A035C47LL, info, 4);
      break;
    default:
      break;
  }
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_set_reflectionclass
Variant c_reflectionclass::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  const char *s = context;
  if (!s) { context = s = FrameInjection::GetClassName(false); }
  int64 hash = hash_string_i(s);
  switch (hash & 1) {
    case 1:
      HASH_GUARD(0x35A44A5E6AE2E71DLL, reflectionclass) { return o_setPrivate(prop, phash, v, forInit); }
      break;
    default:
      break;
  }
  return c_reflectionclass::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionclass
Variant c_reflectionclass::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 1) {
    case 0:
      HASH_SET_STRING(0x0BCDB293DC3DBDDCLL, m_name,
                      name, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionclass
Variant c_reflectionclass::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 1) {
    case 1:
      HASH_SET_STRING(0x3255DC7C4A035C47LL, m_info,
                      info, 4);
      break;
    default:
      break;
  }
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_lval_reflectionclass
Variant& c_reflectionclass::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  const char *s = context;
  if (!s) { context = s = FrameInjection::GetClassName(false); }
  int64 hash = hash_string_i(s);
  switch (hash & 1) {
    case 1:
      HASH_GUARD(0x35A44A5E6AE2E71DLL, reflectionclass) { return o_lvalPrivate(prop, phash); }
      break;
    default:
      break;
  }
  return c_reflectionclass::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionclass
Variant& c_reflectionclass::o_lvalPublic(CStrRef s, int64 hash) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 1) {
    case 0:
      HASH_RETURN_STRING(0x0BCDB293DC3DBDDCLL, m_name,
                         name, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionclass
Variant& c_reflectionclass::o_lvalPrivate(CStrRef s, int64 hash) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 1) {
    case 1:
      HASH_RETURN_STRING(0x3255DC7C4A035C47LL, m_info,
                         info, 4);
      break;
    default:
      break;
  }
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionclass
Variant c_reflectionclass::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_RETURN(0x042E299D3BE2773ALL, q_reflectionclass_IS_IMPLICIT_ABSTRACT, IS_IMPLICIT_ABSTRACT);
      break;
    case 6:
      HASH_RETURN(0x468EF528A19A529ELL, q_reflectionclass_IS_EXPLICIT_ABSTRACT, IS_EXPLICIT_ABSTRACT);
      HASH_RETURN(0x47AAFAC74A59AD66LL, q_reflectionclass_IS_FINAL, IS_FINAL);
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionclass
IMPLEMENT_CLASS(reflectionclass)
c_reflectionclass *c_reflectionclass::create(Variant v_name) {
  CountableHelper h(this);
  init();
  t___construct(v_name);
  return this;
}
ObjectData *c_reflectionclass::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("reflectionclass::__construct", count, 1, 1, 2);
    (t___construct(params[0]));
  }
  return this;
}
void c_reflectionclass::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("reflectionclass::__construct", count, 1, 1, 2);
  (t___construct(params[0]));
}
void c_reflectionclass::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("reflectionclass::__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
ObjectData *c_reflectionclass::cloneImpl() {
  c_reflectionclass *obj = NEW(c_reflectionclass)();
  cloneSet(obj);
  return obj;
}
void c_reflectionclass::cloneSet(c_reflectionclass *clone) {
  clone->m_name = m_name.isReferenced() ? ref(m_name) : m_name;
  clone->m_info = m_info.isReferenced() ? ref(m_info) : m_info;
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionclass
Variant c_reflectionclass::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 127) {
    case 4:
      HASH_GUARD(0x39C1BB731CB1CB04LL, getstartline) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getstartline", 0, 1);
        return (t_getstartline());
      }
      break;
    case 15:
      HASH_GUARD(0x40C7B30DCB439C8FLL, hasproperty) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasproperty", count, 1, 1, 1);
        return (t_hasproperty(params[0]));
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x24253EBA491D6014LL, getmodifiers) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getmodifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 24:
      HASH_GUARD(0x21820E7AA4733998LL, hasmethod) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasmethod", count, 1, 1, 1);
        return (t_hasmethod(params[0]));
      }
      break;
    case 27:
      HASH_GUARD(0x0F1AD0A8EC4C229BLL, getdefaultproperties) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getdefaultproperties", 0, 1);
        return (t_getdefaultproperties());
      }
      break;
    case 30:
      HASH_GUARD(0x1BC5F3D87676509ELL, isinterface) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinterface", 0, 1);
        return (t_isinterface());
      }
      break;
    case 34:
      HASH_GUARD(0x323D9BCB05797B22LL, getstaticproperties) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getstaticproperties", 0, 1);
        return (t_getstaticproperties());
      }
      break;
    case 41:
      HASH_GUARD(0x030CE1D6142F8C29LL, isinstance) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::isinstance", count, 1, 1, 1);
        return (t_isinstance(params[0]));
      }
      HASH_GUARD(0x1D6B8CA358B49929LL, getextensionname) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getextensionname", 0, 1);
        return (t_getextensionname());
      }
      break;
    case 42:
      HASH_GUARD(0x16BA16CE6488AAAALL, getmethods) {
        if (count > 1) return throw_toomany_arguments("reflectionclass::getmethods", 1, 1);
        if (count <= 0) return (t_getmethods());
        return (t_getmethods(params[0]));
      }
      HASH_GUARD(0x226F6E80CECD3CAALL, getconstructor) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstructor", 0, 1);
        return (t_getconstructor());
      }
      HASH_GUARD(0x24596BE6D21F7CAALL, getinterfacenames) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfacenames", 0, 1);
        return (t_getinterfacenames());
      }
      break;
    case 46:
      HASH_GUARD(0x3C882D4A895F612ELL, getstaticpropertyvalue) {
        if (count < 1 || count > 2) return throw_wrong_arguments("reflectionclass::getstaticpropertyvalue", count, 1, 2, 1);
        if (count <= 1) return (t_getstaticpropertyvalue(params[0]));
        return (t_getstaticpropertyvalue(params[0], params[1]));
      }
      HASH_GUARD(0x06FB6A7DC3D795AELL, isfinal) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isfinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 48:
      HASH_GUARD(0x30A86FCA01FE7030LL, newinstance) {
        if (count <= 0) return (t_newinstance(count));
        return (t_newinstance(count,params.slice(0, count - 0, false)));
      }
      break;
    case 52:
      HASH_GUARD(0x3DB53E1FBD3C0734LL, getconstant) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::getconstant", count, 1, 1, 1);
        return (t_getconstant(params[0]));
      }
      break;
    case 54:
      HASH_GUARD(0x0D81ECE253A3B5B6LL, getmethod) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::getmethod", count, 1, 1, 1);
        return (t_getmethod(params[0]));
      }
      break;
    case 55:
      HASH_GUARD(0x7460D945DA32FDB7LL, isabstract) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isabstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 59:
      HASH_GUARD(0x25D24435915E6E3BLL, getextension) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getextension", 0, 1);
        return (t_getextension());
      }
      break;
    case 60:
      HASH_GUARD(0x0D8AAD6BA2BBCD3CLL, isinstantiable) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinstantiable", 0, 1);
        return (t_isinstantiable());
      }
      break;
    case 63:
      HASH_GUARD(0x54C2DC04C4A62B3FLL, hasconstant) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasconstant", count, 1, 1, 1);
        return (t_hasconstant(params[0]));
      }
      break;
    case 67:
      HASH_GUARD(0x67C15E3D98C00B43LL, getinterfaces) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfaces", 0, 1);
        return (t_getinterfaces());
      }
      break;
    case 68:
      HASH_GUARD(0x1EB679C3602F4B44LL, getproperties) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getproperties", 0, 1);
        return (t_getproperties());
      }
      break;
    case 71:
      HASH_GUARD(0x0FD73627FB023047LL, getproperty) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::getproperty", count, 1, 1, 1);
        return (t_getproperty(params[0]));
      }
      break;
    case 77:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getfilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD(0x7D5A57B5370B68CELL, isiterateable) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isiterateable", 0, 1);
        return (t_isiterateable());
      }
      break;
    case 79:
      HASH_GUARD(0x48FDF6C5835C64CFLL, isinternal) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 85:
      HASH_GUARD(0x1CC71CB013143955LL, getconstants) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::__construct", count, 1, 1, 2);
        return (t___construct(params[0]), null);
      }
      break;
    case 100:
      HASH_GUARD(0x6A6B8BECAE7D4164LL, isuserdefined) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isuserdefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 101:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getname", 0, 1);
        return (t_getname());
      }
      break;
    case 102:
      HASH_GUARD(0x2735DCC254EE5C66LL, newinstanceargs) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::newinstanceargs", count, 1, 1, 1);
        return (t_newinstanceargs(params[0]));
      }
      break;
    case 103:
      HASH_GUARD(0x37349B25A0ED29E7LL, test) {
        if (count != 2) return throw_wrong_arguments("reflectionclass::test", count, 2, 2, 1);
        return (t_test(params[0], params[1]));
      }
      break;
    case 104:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 2) return throw_wrong_arguments("reflectionclass::export", count, 2, 2, 1);
        return (ti_export(o_getClassName(), params[0], params[1]));
      }
      break;
    case 112:
      HASH_GUARD(0x6C19E85007BC4570LL, getendline) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getendline", 0, 1);
        return (t_getendline());
      }
      break;
    case 113:
      HASH_GUARD(0x07ECA928E37717F1LL, setstaticpropertyvalue) {
        if (count != 2) return throw_wrong_arguments("reflectionclass::setstaticpropertyvalue", count, 2, 2, 1);
        return (t_setstaticpropertyvalue(params[0], params[1]), null);
      }
      break;
    case 114:
      HASH_GUARD(0x74F7FEDE16957472LL, getparentclass) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getparentclass", 0, 1);
        return (t_getparentclass());
      }
      break;
    case 120:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getdoccomment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 123:
      HASH_GUARD(0x28DC702215C7D6FBLL, implementsinterface) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::implementsinterface", count, 1, 1, 1);
        return (t_implementsinterface(params[0]));
      }
      HASH_GUARD(0x5E82B850BB90B0FBLL, fetch) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::fetch", count, 1, 1, 1);
        return (t_fetch(params[0]));
      }
      break;
    case 126:
      HASH_GUARD(0x373333991926C97ELL, issubclassof) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::issubclassof", count, 1, 1, 1);
        return (t_issubclassof(params[0]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionclass
Variant c_reflectionclass::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 127) {
    case 4:
      HASH_GUARD(0x39C1BB731CB1CB04LL, getstartline) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getstartline", 0, 1);
        return (t_getstartline());
      }
      break;
    case 15:
      HASH_GUARD(0x40C7B30DCB439C8FLL, hasproperty) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasproperty", count, 1, 1, 1);
        return (t_hasproperty(a0));
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x24253EBA491D6014LL, getmodifiers) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getmodifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 24:
      HASH_GUARD(0x21820E7AA4733998LL, hasmethod) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasmethod", count, 1, 1, 1);
        return (t_hasmethod(a0));
      }
      break;
    case 27:
      HASH_GUARD(0x0F1AD0A8EC4C229BLL, getdefaultproperties) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getdefaultproperties", 0, 1);
        return (t_getdefaultproperties());
      }
      break;
    case 30:
      HASH_GUARD(0x1BC5F3D87676509ELL, isinterface) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinterface", 0, 1);
        return (t_isinterface());
      }
      break;
    case 34:
      HASH_GUARD(0x323D9BCB05797B22LL, getstaticproperties) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getstaticproperties", 0, 1);
        return (t_getstaticproperties());
      }
      break;
    case 41:
      HASH_GUARD(0x030CE1D6142F8C29LL, isinstance) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::isinstance", count, 1, 1, 1);
        return (t_isinstance(a0));
      }
      HASH_GUARD(0x1D6B8CA358B49929LL, getextensionname) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getextensionname", 0, 1);
        return (t_getextensionname());
      }
      break;
    case 42:
      HASH_GUARD(0x16BA16CE6488AAAALL, getmethods) {
        if (count > 1) return throw_toomany_arguments("reflectionclass::getmethods", 1, 1);
        if (count <= 0) return (t_getmethods());
        return (t_getmethods(a0));
      }
      HASH_GUARD(0x226F6E80CECD3CAALL, getconstructor) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstructor", 0, 1);
        return (t_getconstructor());
      }
      HASH_GUARD(0x24596BE6D21F7CAALL, getinterfacenames) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfacenames", 0, 1);
        return (t_getinterfacenames());
      }
      break;
    case 46:
      HASH_GUARD(0x3C882D4A895F612ELL, getstaticpropertyvalue) {
        if (count < 1 || count > 2) return throw_wrong_arguments("reflectionclass::getstaticpropertyvalue", count, 1, 2, 1);
        if (count <= 1) return (t_getstaticpropertyvalue(a0));
        return (t_getstaticpropertyvalue(a0, a1));
      }
      HASH_GUARD(0x06FB6A7DC3D795AELL, isfinal) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isfinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 48:
      HASH_GUARD(0x30A86FCA01FE7030LL, newinstance) {
        if (count <= 0) return (t_newinstance(count));
        Array params;
        if (count >= 1) params.append(a0);
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_newinstance(count,params));
      }
      break;
    case 52:
      HASH_GUARD(0x3DB53E1FBD3C0734LL, getconstant) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::getconstant", count, 1, 1, 1);
        return (t_getconstant(a0));
      }
      break;
    case 54:
      HASH_GUARD(0x0D81ECE253A3B5B6LL, getmethod) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::getmethod", count, 1, 1, 1);
        return (t_getmethod(a0));
      }
      break;
    case 55:
      HASH_GUARD(0x7460D945DA32FDB7LL, isabstract) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isabstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 59:
      HASH_GUARD(0x25D24435915E6E3BLL, getextension) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getextension", 0, 1);
        return (t_getextension());
      }
      break;
    case 60:
      HASH_GUARD(0x0D8AAD6BA2BBCD3CLL, isinstantiable) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinstantiable", 0, 1);
        return (t_isinstantiable());
      }
      break;
    case 63:
      HASH_GUARD(0x54C2DC04C4A62B3FLL, hasconstant) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasconstant", count, 1, 1, 1);
        return (t_hasconstant(a0));
      }
      break;
    case 67:
      HASH_GUARD(0x67C15E3D98C00B43LL, getinterfaces) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfaces", 0, 1);
        return (t_getinterfaces());
      }
      break;
    case 68:
      HASH_GUARD(0x1EB679C3602F4B44LL, getproperties) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getproperties", 0, 1);
        return (t_getproperties());
      }
      break;
    case 71:
      HASH_GUARD(0x0FD73627FB023047LL, getproperty) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::getproperty", count, 1, 1, 1);
        return (t_getproperty(a0));
      }
      break;
    case 77:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getfilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD(0x7D5A57B5370B68CELL, isiterateable) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isiterateable", 0, 1);
        return (t_isiterateable());
      }
      break;
    case 79:
      HASH_GUARD(0x48FDF6C5835C64CFLL, isinternal) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 85:
      HASH_GUARD(0x1CC71CB013143955LL, getconstants) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::__construct", count, 1, 1, 2);
        return (t___construct(a0), null);
      }
      break;
    case 100:
      HASH_GUARD(0x6A6B8BECAE7D4164LL, isuserdefined) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::isuserdefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 101:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getname", 0, 1);
        return (t_getname());
      }
      break;
    case 102:
      HASH_GUARD(0x2735DCC254EE5C66LL, newinstanceargs) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::newinstanceargs", count, 1, 1, 1);
        return (t_newinstanceargs(a0));
      }
      break;
    case 103:
      HASH_GUARD(0x37349B25A0ED29E7LL, test) {
        if (count != 2) return throw_wrong_arguments("reflectionclass::test", count, 2, 2, 1);
        return (t_test(a0, a1));
      }
      break;
    case 104:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 2) return throw_wrong_arguments("reflectionclass::export", count, 2, 2, 1);
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 112:
      HASH_GUARD(0x6C19E85007BC4570LL, getendline) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getendline", 0, 1);
        return (t_getendline());
      }
      break;
    case 113:
      HASH_GUARD(0x07ECA928E37717F1LL, setstaticpropertyvalue) {
        if (count != 2) return throw_wrong_arguments("reflectionclass::setstaticpropertyvalue", count, 2, 2, 1);
        return (t_setstaticpropertyvalue(a0, a1), null);
      }
      break;
    case 114:
      HASH_GUARD(0x74F7FEDE16957472LL, getparentclass) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getparentclass", 0, 1);
        return (t_getparentclass());
      }
      break;
    case 120:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        if (count > 0) return throw_toomany_arguments("reflectionclass::getdoccomment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 123:
      HASH_GUARD(0x28DC702215C7D6FBLL, implementsinterface) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::implementsinterface", count, 1, 1, 1);
        return (t_implementsinterface(a0));
      }
      HASH_GUARD(0x5E82B850BB90B0FBLL, fetch) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::fetch", count, 1, 1, 1);
        return (t_fetch(a0));
      }
      break;
    case 126:
      HASH_GUARD(0x373333991926C97ELL, issubclassof) {
        if (count != 1) return throw_wrong_arguments("reflectionclass::issubclassof", count, 1, 1, 1);
        return (t_issubclassof(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionclass
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionclass
Variant c_reflectionclass::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 2) return throw_wrong_arguments("reflectionclass::export", count, 2, 2, 1);
        return (ti_export(c, params[0], params[1]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionclass
Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 127) {
    case 4:
      HASH_GUARD(0x39C1BB731CB1CB04LL, getstartline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getstartline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstartline());
      }
      break;
    case 15:
      HASH_GUARD(0x40C7B30DCB439C8FLL, hasproperty) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasproperty", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasproperty(a0));
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x24253EBA491D6014LL, getmodifiers) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getmodifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmodifiers());
      }
      break;
    case 24:
      HASH_GUARD(0x21820E7AA4733998LL, hasmethod) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasmethod", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasmethod(a0));
      }
      break;
    case 27:
      HASH_GUARD(0x0F1AD0A8EC4C229BLL, getdefaultproperties) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getdefaultproperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdefaultproperties());
      }
      break;
    case 30:
      HASH_GUARD(0x1BC5F3D87676509ELL, isinterface) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinterface", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinterface());
      }
      break;
    case 34:
      HASH_GUARD(0x323D9BCB05797B22LL, getstaticproperties) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getstaticproperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstaticproperties());
      }
      break;
    case 41:
      HASH_GUARD(0x030CE1D6142F8C29LL, isinstance) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::isinstance", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinstance(a0));
      }
      HASH_GUARD(0x1D6B8CA358B49929LL, getextensionname) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getextensionname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getextensionname());
      }
      break;
    case 42:
      HASH_GUARD(0x16BA16CE6488AAAALL, getmethods) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("reflectionclass::getmethods", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getmethods());
        else return (t_getmethods(a0));
      }
      HASH_GUARD(0x226F6E80CECD3CAALL, getconstructor) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstructor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstructor());
      }
      HASH_GUARD(0x24596BE6D21F7CAALL, getinterfacenames) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfacenames", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinterfacenames());
      }
      break;
    case 46:
      HASH_GUARD(0x3C882D4A895F612ELL, getstaticpropertyvalue) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("reflectionclass::getstaticpropertyvalue", count, 1, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t_getstaticpropertyvalue(a0));
        else return (t_getstaticpropertyvalue(a0, a1));
      }
      HASH_GUARD(0x06FB6A7DC3D795AELL, isfinal) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::isfinal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isfinal());
      }
      break;
    case 48:
      HASH_GUARD(0x30A86FCA01FE7030LL, newinstance) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 0) return (t_newinstance(count));
        return (t_newinstance(count,vargs));
      }
      break;
    case 52:
      HASH_GUARD(0x3DB53E1FBD3C0734LL, getconstant) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::getconstant", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstant(a0));
      }
      break;
    case 54:
      HASH_GUARD(0x0D81ECE253A3B5B6LL, getmethod) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::getmethod", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmethod(a0));
      }
      break;
    case 55:
      HASH_GUARD(0x7460D945DA32FDB7LL, isabstract) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::isabstract", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isabstract());
      }
      break;
    case 59:
      HASH_GUARD(0x25D24435915E6E3BLL, getextension) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getextension", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getextension());
      }
      break;
    case 60:
      HASH_GUARD(0x0D8AAD6BA2BBCD3CLL, isinstantiable) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinstantiable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinstantiable());
      }
      break;
    case 63:
      HASH_GUARD(0x54C2DC04C4A62B3FLL, hasconstant) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::hasconstant", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_hasconstant(a0));
      }
      break;
    case 67:
      HASH_GUARD(0x67C15E3D98C00B43LL, getinterfaces) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfaces", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinterfaces());
      }
      break;
    case 68:
      HASH_GUARD(0x1EB679C3602F4B44LL, getproperties) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getproperties", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getproperties());
      }
      break;
    case 71:
      HASH_GUARD(0x0FD73627FB023047LL, getproperty) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::getproperty", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getproperty(a0));
      }
      break;
    case 77:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getfilename", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD(0x7D5A57B5370B68CELL, isiterateable) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::isiterateable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isiterateable());
      }
      break;
    case 79:
      HASH_GUARD(0x48FDF6C5835C64CFLL, isinternal) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::isinternal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinternal());
      }
      break;
    case 85:
      HASH_GUARD(0x1CC71CB013143955LL, getconstants) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstants", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstants());
      }
      break;
    case 95:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::__construct", count, 1, 1, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 100:
      HASH_GUARD(0x6A6B8BECAE7D4164LL, isuserdefined) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::isuserdefined", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isuserdefined());
      }
      break;
    case 101:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 102:
      HASH_GUARD(0x2735DCC254EE5C66LL, newinstanceargs) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::newinstanceargs", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_newinstanceargs(a0));
      }
      break;
    case 103:
      HASH_GUARD(0x37349B25A0ED29E7LL, test) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("reflectionclass::test", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_test(a0, a1));
      }
      break;
    case 104:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("reflectionclass::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 112:
      HASH_GUARD(0x6C19E85007BC4570LL, getendline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getendline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getendline());
      }
      break;
    case 113:
      HASH_GUARD(0x07ECA928E37717F1LL, setstaticpropertyvalue) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("reflectionclass::setstaticpropertyvalue", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setstaticpropertyvalue(a0, a1), null);
      }
      break;
    case 114:
      HASH_GUARD(0x74F7FEDE16957472LL, getparentclass) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getparentclass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getparentclass());
      }
      break;
    case 120:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionclass::getdoccomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    case 123:
      HASH_GUARD(0x28DC702215C7D6FBLL, implementsinterface) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::implementsinterface", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_implementsinterface(a0));
      }
      HASH_GUARD(0x5E82B850BB90B0FBLL, fetch) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::fetch", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fetch(a0));
      }
      break;
    case 126:
      HASH_GUARD(0x373333991926C97ELL, issubclassof) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionclass::issubclassof", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_issubclassof(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_reflectionclass::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("reflectionclass::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_reflectionclass = {
  c_reflectionclass::os_getInit,
  c_reflectionclass::os_get,
  c_reflectionclass::os_lval,
  c_reflectionclass::os_invoke,
  c_reflectionclass::os_constant,
};
void c_reflectionclass::init() {
  m_name = null;
  m_info = null;
}
/* SRC: classes/reflection.php line 210 */
void c_reflectionclass::t___construct(Variant v_name) {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::__construct);
  bool oldInCtor = gasInCtor(true);
  if (x_is_object(v_name)) {
    {
      {
        const Variant &tmp11((x_get_class(v_name)));
        (v_name = tmp11);
      }
    }
  }
  else {
    {
      if (!(toBoolean(x_call_user_func(2, "class_exists", Array(ArrayInit(1, true).set(0, v_name).create())))) && !(toBoolean(x_call_user_func(2, "interface_exists", Array(ArrayInit(1, true).set(0, v_name).create()))))) {
        {
          {
            c_reflectionexception *tmp12 = NEWOBJ(c_reflectionexception)();
            throw_exception(p_reflectionexception(tmp12->create(StringBuffer().add("Class ", 6).add(toString(v_name)).add(" does not exist", 15).detach())));
          }
        }
      }
    }
  }
  (m_name = v_name);
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/reflection.php line 223 */
Variant c_reflectionclass::t_fetch(CVarRef v_what) {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::fetch);
  Variant v_name;
  Primitive v_interface = 0;
  Variant v__;
  p_reflectionclass v_p;

  if (!(toBoolean(m_info))) {
    {
      (m_info = x_call_user_func(2, "hphp_get_class_info", Array(ArrayInit(1, true).set(0, m_name).create())));
      if (empty(m_info)) {
        {
          {
            c_reflectionexception *tmp13 = NEWOBJ(c_reflectionexception)();
            throw_exception(p_reflectionexception(tmp13->create(StringBuffer().add("Class ", 6).add(toString(v_name)).add(" does not exist", 15).detach())));
          }
        }
      }
      {
        LOOP_COUNTER(14);
        Variant map15 = m_info.rvalAt("interfaces", 0x0C5BD661CFB9E254LL, true, true);
        for (ArrayIterPtr iter16 = map15.begin("reflectionclass"); !iter16->end(); iter16->next()) {
          LOOP_COUNTER_CHECK(14);
          iter16->second(v__);
          v_interface = iter16->first();
          {
            {
              c_reflectionclass *tmp17 = NEWOBJ(c_reflectionclass)();
              p_reflectionclass tmp18((p_reflectionclass(tmp17->create(v_interface))));
              (v_p = tmp18);
            }
            lval(m_info.lvalAt("methods", 0x2A7E90235B229AD5LL, false, true)) += AS_CLASS(v_p,c_reflectionclass)->t_fetch("methods");
          }
        }
      }
      if (!(empty(m_info, "parent", 0x3E764E41E4A6ACA5LL, true))) {
        {
          {
            c_reflectionclass *tmp19 = NEWOBJ(c_reflectionclass)();
            p_reflectionclass tmp20((p_reflectionclass(tmp19->create(m_info.rvalAt("parent", 0x3E764E41E4A6ACA5LL, true, true)))));
            (v_p = tmp20);
          }
          lval(m_info.lvalAt("interfaces", 0x0C5BD661CFB9E254LL, false, true)) += AS_CLASS(v_p,c_reflectionclass)->t_fetch("interfaces");
          lval(m_info.lvalAt("properties", 0x5D7B5CC390269404LL, false, true)) += AS_CLASS(v_p,c_reflectionclass)->m_info.rvalAt("properties", 0x5D7B5CC390269404LL, true, true);
          lval(m_info.lvalAt("methods", 0x2A7E90235B229AD5LL, false, true)) += AS_CLASS(v_p,c_reflectionclass)->m_info.rvalAt("methods", 0x2A7E90235B229AD5LL, true, true);
          lval(m_info.lvalAt("constants", 0x61A5DA894BD05406LL, false, true)) += AS_CLASS(v_p,c_reflectionclass)->m_info.rvalAt("constants", 0x61A5DA894BD05406LL, true, true);
        }
      }
    }
  }
  return m_info.rvalAt(v_what, -1, true);
} /* function */
/* SRC: classes/reflection.php line 246 */
bool c_reflectionclass::t_test(CStrRef v_what, CVarRef v_name) {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::test);
  Variant v_v;

  {
    Variant tmp21((t_fetch(v_what)));
    (v_v = tmp21);
  }
  return toBoolean(v_v) && isset(v_v, v_name);
} /* function */
/* SRC: classes/reflection.php line 251 */
String c_reflectionclass::t___tostring() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::__toString);
  return toString(null);
} /* function */
/* SRC: classes/reflection.php line 254 */
Variant c_reflectionclass::ti_export(const char* cls, CVarRef v_name, CVarRef v_ret) {
  STATIC_METHOD_INJECTION(ReflectionClass, ReflectionClass::export);
  p_reflectionclass v_obj;
  String v_str;

  {
    c_reflectionclass *tmp22 = NEWOBJ(c_reflectionclass)();
    p_reflectionclass tmp23((p_reflectionclass(tmp22->create(v_name))));
    (v_obj = tmp23);
  }
  (v_str = (toString(v_obj)));
  if (toBoolean(v_ret)) {
    {
      return v_str;
    }
  }
  print(v_str);
  return null;
} /* function */
/* SRC: classes/reflection.php line 263 */
Variant c_reflectionclass::t_getname() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getName);
  return t_fetch("name");
} /* function */
/* SRC: classes/reflection.php line 267 */
Variant c_reflectionclass::t_isinternal() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::isInternal);
  return t_fetch("internal");
} /* function */
/* SRC: classes/reflection.php line 271 */
bool c_reflectionclass::t_isuserdefined() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::isUserDefined);
  return !(toBoolean(t_fetch("internal")));
} /* function */
/* SRC: classes/reflection.php line 275 */
bool c_reflectionclass::t_isinstantiable() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::isInstantiable);
  return !(toBoolean(t_fetch("abstract")));
} /* function */
/* SRC: classes/reflection.php line 279 */
bool c_reflectionclass::t_hasconstant(CVarRef v_name) {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::hasConstant);
  return t_test("constants", v_name);
} /* function */
/* SRC: classes/reflection.php line 283 */
bool c_reflectionclass::t_hasmethod(CVarRef v_name) {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::hasMethod);
  return t_test("methods", x_strtolower(toString(v_name)));
} /* function */
/* SRC: classes/reflection.php line 287 */
bool c_reflectionclass::t_hasproperty(CVarRef v_name) {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::hasProperty);
  return t_test("properties", v_name);
} /* function */
/* SRC: classes/reflection.php line 291 */
Variant c_reflectionclass::t_getfilename() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getFileName);
  return t_fetch("file");
} /* function */
/* SRC: classes/reflection.php line 295 */
Variant c_reflectionclass::t_getstartline() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getStartLine);
  return t_fetch("line1");
} /* function */
/* SRC: classes/reflection.php line 299 */
Variant c_reflectionclass::t_getendline() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getEndLine);
  return t_fetch("line2");
} /* function */
/* SRC: classes/reflection.php line 303 */
Variant c_reflectionclass::t_getdoccomment() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getDocComment);
  return t_fetch("doc");
} /* function */
/* SRC: classes/reflection.php line 307 */
Variant c_reflectionclass::t_getconstructor() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getConstructor);
  Variant v_name;

  if (t_hasmethod("__construct")) {
    {
      return t_getmethod("__construct");
    }
  }
  {
    bool tmp24;
    {
      Variant tmp25((t_fetch("name")));
      tmp24 = (t_hasmethod((v_name = tmp25)));
    }
    if (tmp24) {
      {
        return t_getmethod(v_name);
      }
    }
  }
  return null;
} /* function */
/* SRC: classes/reflection.php line 317 */
p_reflectionmethod c_reflectionclass::t_getmethod(CVarRef v_name) {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getMethod);
  String v_lname;
  Variant v_methods;
  Variant v_class;
  p_reflectionmethod v_ret;

  {
    const String &tmp26((x_strtolower(toString(v_name))));
    (v_lname = tmp26);
  }
  {
    Variant tmp27((t_fetch("methods")));
    (v_methods = tmp27);
  }
  if (!(isset(v_methods, v_lname))) {
    {
      {
        Variant tmp28((m_info.rvalAt("name", 0x0BCDB293DC3DBDDCLL, true, true)));
        (v_class = tmp28);
      }
      {
        c_reflectionexception *tmp29 = NEWOBJ(c_reflectionexception)();
        throw_exception(p_reflectionexception(tmp29->create(StringBuffer().add("Method ", 7).add(toString(v_class)).add("::", 2).add(toString(v_name)).add(" does not exist", 15).detach())));
      }
    }
  }
  {
    p_reflectionmethod tmp30((p_reflectionmethod((NEWOBJ(c_reflectionmethod)())->create(null, null))));
    (v_ret = tmp30);
  }
  (AS_CLASS(v_ret,c_reflectionmethod)->m_info = v_methods.rvalAt(v_lname, -1, true));
  (AS_CLASS(v_ret,c_reflectionmethod)->m_name = v_lname);
  (AS_CLASS(v_ret,c_reflectionmethod)->m_class = m_info.rvalAt("name", 0x0BCDB293DC3DBDDCLL, true, true));
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 332 */
Array c_reflectionclass::t_getmethods(int64 v_filter //  = 65535LL
) {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getMethods);
  Array v_ret;
  Variant v_methods;
  Primitive v_name = 0;
  Variant v__;
  p_reflectionmethod v_m;

  (v_ret = SystemScalarArrays::ssa_[0]);
  {
    Variant tmp31((t_fetch("methods")));
    (v_methods = tmp31);
  }
  {
    LOOP_COUNTER(32);
    for (ArrayIterPtr iter34 = v_methods.begin("reflectionclass"); !iter34->end(); iter34->next()) {
      LOOP_COUNTER_CHECK(32);
      iter34->second(v__);
      v_name = iter34->first();
      {
        {
          p_reflectionmethod tmp35((t_getmethod(v_name)));
          (v_m = tmp35);
        }
        if (toBoolean(((bitwise_and(v_filter, 256LL /* reflectionmethod::IS_PUBLIC */)))) && AS_CLASS(v_m,c_reflectionmethod)->t_ispublic() || toBoolean(((bitwise_and(v_filter, 512LL /* reflectionmethod::IS_PROTECTED */)))) && AS_CLASS(v_m,c_reflectionmethod)->t_isprotected() || toBoolean(((bitwise_and(v_filter, 1024LL /* reflectionmethod::IS_PRIVATE */)))) && AS_CLASS(v_m,c_reflectionmethod)->t_isprivate() || toBoolean(((bitwise_and(v_filter, 1LL /* reflectionmethod::IS_STATIC */)))) && toBoolean(AS_CLASS(v_m,c_reflectionmethod)->t_isstatic()) || toBoolean(((bitwise_and(v_filter, 4LL /* reflectionmethod::IS_FINAL */)))) && toBoolean(AS_CLASS(v_m,c_reflectionmethod)->t_isfinal()) || ((toBoolean(bitwise_and(v_filter, 2LL /* reflectionmethod::IS_ABSTRACT */)) && toBoolean(AS_CLASS(v_m,c_reflectionmethod)->t_isabstract())))) {
          {
            v_ret.append((v_m));
          }
        }
      }
    }
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 349 */
p_reflectionproperty c_reflectionclass::t_getproperty(CVarRef v_name) {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getProperty);
  Variant v_properties;
  Variant v_class;
  p_reflectionproperty v_ret;

  {
    Variant tmp36((t_fetch("properties")));
    (v_properties = tmp36);
  }
  if (!(isset(v_properties, v_name))) {
    {
      {
        Variant tmp37((m_info.rvalAt("name", 0x0BCDB293DC3DBDDCLL, true, true)));
        (v_class = tmp37);
      }
      {
        c_reflectionexception *tmp38 = NEWOBJ(c_reflectionexception)();
        throw_exception(p_reflectionexception(tmp38->create(StringBuffer().add("Property ", 9).add(toString(v_class)).add("::", 2).add(toString(v_name)).add(" does not exist", 15).detach())));
      }
    }
  }
  {
    p_reflectionproperty tmp39((p_reflectionproperty((NEWOBJ(c_reflectionproperty)())->create(null, null))));
    (v_ret = tmp39);
  }
  (AS_CLASS(v_ret,c_reflectionproperty)->m_info = v_properties.rvalAt(v_name, -1, true));
  (AS_CLASS(v_ret,c_reflectionproperty)->m_name = v_name);
  (AS_CLASS(v_ret,c_reflectionproperty)->m_class = m_info.rvalAt("name", 0x0BCDB293DC3DBDDCLL, true, true));
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 363 */
Array c_reflectionclass::t_getproperties() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getProperties);
  Array v_ret;
  Primitive v_name = 0;
  Variant v__;

  (v_ret = SystemScalarArrays::ssa_[0]);
  {
    LOOP_COUNTER(40);
    Variant map41 = t_fetch("properties");
    for (ArrayIterPtr iter42 = map41.begin("reflectionclass"); !iter42->end(); iter42->next()) {
      LOOP_COUNTER_CHECK(40);
      iter42->second(v__);
      v_name = iter42->first();
      {
        v_ret.append((t_getproperty(v_name)));
      }
    }
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 371 */
Variant c_reflectionclass::t_getconstants() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getConstants);
  return t_fetch("constants");
} /* function */
/* SRC: classes/reflection.php line 375 */
Variant c_reflectionclass::t_getconstant(CVarRef v_name) {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getConstant);
  Variant v_constants;
  Variant v_class;

  {
    Variant tmp43((t_fetch("constants")));
    (v_constants = tmp43);
  }
  if (!(isset(v_constants, v_name))) {
    {
      {
        Variant tmp44((m_info.rvalAt("name", 0x0BCDB293DC3DBDDCLL, true, true)));
        (v_class = tmp44);
      }
      {
        c_reflectionexception *tmp45 = NEWOBJ(c_reflectionexception)();
        throw_exception(p_reflectionexception(tmp45->create(StringBuffer().add("Class constant ", 15).add(toString(v_class)).add("::", 2).add(toString(v_name)).add(" does not exist", 15).detach())));
      }
    }
  }
  return v_constants.rvalAt(v_name, -1, true);
} /* function */
/* SRC: classes/reflection.php line 384 */
Variant c_reflectionclass::t_getinterfaces() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getInterfaces);
  Variant v_ret;
  Primitive v_name = 0;
  Variant v__;
  p_reflectionclass v_cls;

  (v_ret = SystemScalarArrays::ssa_[0]);
  {
    LOOP_COUNTER(46);
    Variant map47 = t_fetch("interfaces");
    for (ArrayIterPtr iter48 = map47.begin("reflectionclass"); !iter48->end(); iter48->next()) {
      LOOP_COUNTER_CHECK(46);
      iter48->second(v__);
      v_name = iter48->first();
      {
        {
          c_reflectionclass *tmp49 = NEWOBJ(c_reflectionclass)();
          p_reflectionclass tmp50((p_reflectionclass(tmp49->create(v_name))));
          (v_cls = tmp50);
        }
        if (toBoolean(AS_CLASS(v_cls,c_reflectionclass)->t_isinterface())) {
          {
            {
              Variant tmp51((AS_CLASS(v_cls,c_reflectionclass)->t_getname()));
              v_ret.set(tmp51, (v_cls));
            }
          }
        }
      }
    }
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 395 */
Array c_reflectionclass::t_getinterfacenames() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getInterfaceNames);
  Array v_ret;
  Primitive v_name = 0;
  Variant v__;
  p_reflectionclass v_cls;

  (v_ret = SystemScalarArrays::ssa_[0]);
  {
    LOOP_COUNTER(52);
    Variant map53 = t_fetch("interfaces");
    for (ArrayIterPtr iter54 = map53.begin("reflectionclass"); !iter54->end(); iter54->next()) {
      LOOP_COUNTER_CHECK(52);
      iter54->second(v__);
      v_name = iter54->first();
      {
        {
          c_reflectionclass *tmp55 = NEWOBJ(c_reflectionclass)();
          p_reflectionclass tmp56((p_reflectionclass(tmp55->create(v_name))));
          (v_cls = tmp56);
        }
        if (toBoolean(AS_CLASS(v_cls,c_reflectionclass)->t_isinterface())) {
          {
            v_ret.append((AS_CLASS(v_cls,c_reflectionclass)->t_getname()));
          }
        }
      }
    }
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 406 */
Variant c_reflectionclass::t_isinterface() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::isInterface);
  return t_fetch("interface");
} /* function */
/* SRC: classes/reflection.php line 410 */
Variant c_reflectionclass::t_isabstract() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::isAbstract);
  return t_fetch("abstract");
} /* function */
/* SRC: classes/reflection.php line 414 */
Variant c_reflectionclass::t_isfinal() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::isFinal);
  return t_fetch("final");
} /* function */
/* SRC: classes/reflection.php line 418 */
Variant c_reflectionclass::t_getmodifiers() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getModifiers);
  return t_fetch("modifiers");
} /* function */
/* SRC: classes/reflection.php line 422 */
bool c_reflectionclass::t_isinstance(CVarRef v_obj) {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::isInstance);
  return x_hphp_instanceof(toObject(v_obj), toString(m_name));
} /* function */
/* SRC: classes/reflection.php line 426 */
Object c_reflectionclass::t_newinstance(int num_args, Array args /* = Array() */) {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::newInstance);
  Array v_args;

  {
    const Array &tmp57((func_get_args(num_args, Array(),args)));
    (v_args = tmp57);
  }
  return x_hphp_create_object(toString(m_name), v_args);
} /* function */
/* SRC: classes/reflection.php line 431 */
Object c_reflectionclass::t_newinstanceargs(CVarRef v_args) {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::newInstanceArgs);
  return x_hphp_create_object(toString(m_name), toArray(v_args));
} /* function */
/* SRC: classes/reflection.php line 435 */
Variant c_reflectionclass::t_getparentclass() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getParentClass);
  if (empty(t_fetch("parent"))) {
    {
      return false;
    }
  }
  {
    c_reflectionclass *tmp58 = NEWOBJ(c_reflectionclass)();
    return p_reflectionclass(tmp58->create(t_fetch("parent")));
  }
} /* function */
/* SRC: classes/reflection.php line 442 */
Variant c_reflectionclass::t_issubclassof(Variant v_cls) {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::isSubclassOf);
  Primitive v_name = 0;
  Variant v__;

  if (instanceOf(v_cls, "ReflectionClass")) {
    {
      {
        Variant tmp59((v_cls. BIND_CLASS_DOT o_invoke_few_args("fetch", 0x5E82B850BB90B0FBLL, 1, "name")));
        (v_cls = tmp59);
      }
    }
  }
  {
    LOOP_COUNTER(60);
    Variant map61 = t_fetch("interfaces");
    for (ArrayIterPtr iter62 = map61.begin("reflectionclass"); !iter62->end(); iter62->next()) {
      LOOP_COUNTER_CHECK(60);
      iter62->second(v__);
      v_name = iter62->first();
      {
        if (equal(x_strcasecmp(toString(v_cls), toString(v_name)), 0LL)) {
          {
            return true;
          }
        }
      }
    }
  }
  if (empty(t_fetch("parent"))) {
    {
      return false;
    }
  }
  {
    bool tmp63;
    {
      String tmp64((toString(v_cls)));
      String tmp65((toString(t_fetch("parent"))));
      tmp63 = (equal(x_strcasecmp(tmp64, tmp65), 0LL));
    }
    if (tmp63) {
      {
        return true;
      }
    }
  }
  {
    Object tmp66((toObject(t_getparentclass())));
    return tmp66-> BIND_CLASS_ARROW(ObjectData) o_invoke_few_args("isSubclassOf", 0x373333991926C97ELL, 1, v_cls);
  }
} /* function */
/* SRC: classes/reflection.php line 460 */
Variant c_reflectionclass::t_getstaticproperties() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getStaticProperties);
  Variant v_ret;
  Variant v_prop;

  (v_ret = SystemScalarArrays::ssa_[0]);
  {
    LOOP_COUNTER(67);
    Variant map68 = t_getproperties();
    for (ArrayIterPtr iter69 = map68.begin("reflectionclass"); !iter69->end(); iter69->next()) {
      LOOP_COUNTER_CHECK(67);
      iter69->second(v_prop);
      {
        if (toBoolean(v_prop. BIND_CLASS_DOT o_invoke_few_args("isStatic", 0x7A15DC56E8CC0B19LL, 0))) {
          {
            {
              Variant tmp70((v_prop.o_get("name", 0x0BCDB293DC3DBDDCLL)));
              v_ret.set(tmp70, (v_prop));
            }
          }
        }
      }
    }
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 470 */
Variant c_reflectionclass::t_getstaticpropertyvalue(CVarRef v_name, CVarRef v_default //  = null_variant
) {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getStaticPropertyValue);
  if (t_hasproperty(v_name) && toBoolean(AS_CLASS(t_getproperty(v_name),c_reflectionproperty)->t_isstatic())) {
    {
      return x_hphp_get_static_property(toString(m_name), toString(v_name));
    }
  }
  return v_default;
} /* function */
/* SRC: classes/reflection.php line 478 */
void c_reflectionclass::t_setstaticpropertyvalue(CVarRef v_name, CVarRef v_value) {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::setStaticPropertyValue);
  x_hphp_set_static_property(toString(m_name), toString(v_name), v_value);
} /* function */
/* SRC: classes/reflection.php line 482 */
Variant c_reflectionclass::t_getdefaultproperties() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getDefaultProperties);
  Variant v_ret;
  Variant v_prop;

  (v_ret = SystemScalarArrays::ssa_[0]);
  {
    LOOP_COUNTER(71);
    Variant map72 = t_getproperties();
    for (ArrayIterPtr iter73 = map72.begin("reflectionclass"); !iter73->end(); iter73->next()) {
      LOOP_COUNTER_CHECK(71);
      iter73->second(v_prop);
      {
        if (toBoolean(v_prop. BIND_CLASS_DOT o_invoke_few_args("isDefault", 0x384A52597AB11F15LL, 0))) {
          {
            {
              Variant tmp74((v_prop.o_get("name", 0x0BCDB293DC3DBDDCLL)));
              v_ret.set(tmp74, (v_prop));
            }
          }
        }
      }
    }
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 492 */
Variant c_reflectionclass::t_isiterateable() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::isIterateable);
  return t_issubclassof("ArrayAccess");
} /* function */
/* SRC: classes/reflection.php line 496 */
bool c_reflectionclass::t_implementsinterface(Variant v_cls) {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::implementsInterface);
  Primitive v_name = 0;
  Variant v__;

  if (instanceOf(v_cls, "ReflectionClass")) {
    {
      {
        Variant tmp75((v_cls. BIND_CLASS_DOT o_invoke_few_args("fetch", 0x5E82B850BB90B0FBLL, 1, "name")));
        (v_cls = tmp75);
      }
    }
  }
  {
    LOOP_COUNTER(76);
    Variant map77 = t_fetch("interfaces");
    for (ArrayIterPtr iter78 = map77.begin("reflectionclass"); !iter78->end(); iter78->next()) {
      LOOP_COUNTER_CHECK(76);
      iter78->second(v__);
      v_name = iter78->first();
      {
        if (equal(x_strcasecmp(toString(v_cls), toString(v_name)), 0LL)) {
          {
            return true;
          }
        }
      }
    }
  }
  return false;
} /* function */
/* SRC: classes/reflection.php line 508 */
Variant c_reflectionclass::t_getextension() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getExtension);
  return t_fetch("extension");
} /* function */
/* SRC: classes/reflection.php line 512 */
Variant c_reflectionclass::t_getextensionname() {
  INSTANCE_METHOD_INJECTION(ReflectionClass, ReflectionClass::getExtensionName);
  return t_fetch("extension"). BIND_CLASS_DOT o_invoke_few_args("getName", 0x23F51CDECC198965LL, 0);
} /* function */
/* SRC: classes/reflection.php line 736 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionextension
Variant c_reflectionextension::os_getInit(const char *s, int64 hash) {
  DECLARE_SYSTEM_GLOBALS(g);
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 0:
      HASH_RETURN(0x0BCDB293DC3DBDDCLL, 
                  null, name);
      break;
    case 3:
      HASH_RETURN(0x3255DC7C4A035C47LL, 
                  null, info);
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionextension
Variant c_reflectionextension::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionextension
Variant &c_reflectionextension::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionextension
void c_reflectionextension::o_get(Array &props) const {
  if (isInitialized(m_name)) props.set(String("\0reflectionextension\0name", 25, CopyString), m_name.isReferenced() ? ref(m_name) : m_name, 0x19A2EB7C8F3C0D32LL, true);
  if (isInitialized(m_info)) props.set(String("\0reflectionextension\0info", 25, CopyString), m_info.isReferenced() ? ref(m_info) : m_info, 0x63734519071A4FA3LL, true);
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_get_reflectionextension
Variant c_reflectionextension::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  const char *s = context;
  if (!s) { context = s = FrameInjection::GetClassName(false); }
  int64 hash = hash_string_i(s);
  switch (hash & 1) {
    case 1:
      HASH_GUARD(0x0B61E0BFCFA06573LL, reflectionextension) { return o_getPrivate(prop, phash, error); }
      break;
    default:
      break;
  }
  return c_reflectionextension::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionextension
Variant c_reflectionextension::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionextension
Variant c_reflectionextension::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 3) {
    case 0:
      HASH_RETURN_STRING(0x0BCDB293DC3DBDDCLL, m_name,
                         name, 4);
      break;
    case 3:
      HASH_RETURN_STRING(0x3255DC7C4A035C47LL, m_info,
                         info, 4);
      break;
    default:
      break;
  }
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_exists_reflectionextension
bool c_reflectionextension::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  const char *s = context;
  if (!s) { context = s = FrameInjection::GetClassName(false); }
  int64 hash = hash_string_i(s);
  switch (hash & 1) {
    case 1:
      HASH_GUARD(0x0B61E0BFCFA06573LL, reflectionextension) { return o_existsPrivate(prop, phash); }
      break;
    default:
      break;
  }
  return c_reflectionextension::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionextension
bool c_reflectionextension::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionextension
bool c_reflectionextension::o_existsPrivate(CStrRef s, int64 hash) const {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 3) {
    case 0:
      HASH_EXISTS_STRING(0x0BCDB293DC3DBDDCLL, name, 4);
      break;
    case 3:
      HASH_EXISTS_STRING(0x3255DC7C4A035C47LL, info, 4);
      break;
    default:
      break;
  }
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_set_reflectionextension
Variant c_reflectionextension::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  const char *s = context;
  if (!s) { context = s = FrameInjection::GetClassName(false); }
  int64 hash = hash_string_i(s);
  switch (hash & 1) {
    case 1:
      HASH_GUARD(0x0B61E0BFCFA06573LL, reflectionextension) { return o_setPrivate(prop, phash, v, forInit); }
      break;
    default:
      break;
  }
  return c_reflectionextension::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionextension
Variant c_reflectionextension::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionextension
Variant c_reflectionextension::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 3) {
    case 0:
      HASH_SET_STRING(0x0BCDB293DC3DBDDCLL, m_name,
                      name, 4);
      break;
    case 3:
      HASH_SET_STRING(0x3255DC7C4A035C47LL, m_info,
                      info, 4);
      break;
    default:
      break;
  }
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_lval_reflectionextension
Variant& c_reflectionextension::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  const char *s = context;
  if (!s) { context = s = FrameInjection::GetClassName(false); }
  int64 hash = hash_string_i(s);
  switch (hash & 1) {
    case 1:
      HASH_GUARD(0x0B61E0BFCFA06573LL, reflectionextension) { return o_lvalPrivate(prop, phash); }
      break;
    default:
      break;
  }
  return c_reflectionextension::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionextension
Variant& c_reflectionextension::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionextension
Variant& c_reflectionextension::o_lvalPrivate(CStrRef s, int64 hash) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 3) {
    case 0:
      HASH_RETURN_STRING(0x0BCDB293DC3DBDDCLL, m_name,
                         name, 4);
      break;
    case 3:
      HASH_RETURN_STRING(0x3255DC7C4A035C47LL, m_info,
                         info, 4);
      break;
    default:
      break;
  }
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionextension
Variant c_reflectionextension::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionextension
IMPLEMENT_CLASS(reflectionextension)
c_reflectionextension *c_reflectionextension::create(Variant v_name) {
  CountableHelper h(this);
  init();
  t___construct(v_name);
  return this;
}
ObjectData *c_reflectionextension::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("reflectionextension::__construct", count, 1, 1, 2);
    (t___construct(params[0]));
  }
  return this;
}
void c_reflectionextension::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("reflectionextension::__construct", count, 1, 1, 2);
  (t___construct(params[0]));
}
void c_reflectionextension::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("reflectionextension::__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
ObjectData *c_reflectionextension::cloneImpl() {
  c_reflectionextension *obj = NEW(c_reflectionextension)();
  cloneSet(obj);
  return obj;
}
void c_reflectionextension::cloneSet(c_reflectionextension *clone) {
  clone->m_name = m_name.isReferenced() ? ref(m_name) : m_name;
  clone->m_info = m_info.isReferenced() ? ref(m_info) : m_info;
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionextension
Variant c_reflectionextension::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 2:
      HASH_GUARD(0x0113D73FC859EDC2LL, getclasses) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::getclasses", 0, 1);
        return (t_getclasses());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::getname", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 2) return throw_wrong_arguments("reflectionextension::export", count, 2, 2, 1);
        return (ti_export(o_getClassName(), params[0], params[1]));
      }
      break;
    case 15:
      HASH_GUARD(0x652BDFA6E22F17AFLL, getfunctions) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::getfunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x5CE2786E11341594LL, getclassnames) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::getclassnames", 0, 1);
        return (t_getclassnames());
      }
      break;
    case 21:
      HASH_GUARD(0x306B5F4D1D03D335LL, getinientries) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::getinientries", 0, 1);
        return (t_getinientries());
      }
      HASH_GUARD(0x1CC71CB013143955LL, getconstants) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::getconstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 22:
      HASH_GUARD(0x7521E8833BE3D316LL, getversion) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::getversion", 0, 1);
        return (t_getversion());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("reflectionextension::__construct", count, 1, 1, 2);
        return (t___construct(params[0]), null);
      }
      HASH_GUARD(0x0F2EF58F157D479FLL, info) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::info", 0, 1);
        return (t_info());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionextension
Variant c_reflectionextension::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 2:
      HASH_GUARD(0x0113D73FC859EDC2LL, getclasses) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::getclasses", 0, 1);
        return (t_getclasses());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::getname", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 2) return throw_wrong_arguments("reflectionextension::export", count, 2, 2, 1);
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x652BDFA6E22F17AFLL, getfunctions) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::getfunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x5CE2786E11341594LL, getclassnames) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::getclassnames", 0, 1);
        return (t_getclassnames());
      }
      break;
    case 21:
      HASH_GUARD(0x306B5F4D1D03D335LL, getinientries) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::getinientries", 0, 1);
        return (t_getinientries());
      }
      HASH_GUARD(0x1CC71CB013143955LL, getconstants) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::getconstants", 0, 1);
        return (t_getconstants());
      }
      break;
    case 22:
      HASH_GUARD(0x7521E8833BE3D316LL, getversion) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::getversion", 0, 1);
        return (t_getversion());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("reflectionextension::__construct", count, 1, 1, 2);
        return (t___construct(a0), null);
      }
      HASH_GUARD(0x0F2EF58F157D479FLL, info) {
        if (count > 0) return throw_toomany_arguments("reflectionextension::info", 0, 1);
        return (t_info());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionextension
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionextension
Variant c_reflectionextension::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 2) return throw_wrong_arguments("reflectionextension::export", count, 2, 2, 1);
        return (ti_export(c, params[0], params[1]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionextension
Variant c_reflectionextension::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 2:
      HASH_GUARD(0x0113D73FC859EDC2LL, getclasses) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionextension::getclasses", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclasses());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionextension::getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("reflectionextension::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 15:
      HASH_GUARD(0x652BDFA6E22F17AFLL, getfunctions) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionextension::getfunctions", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfunctions());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionextension::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x5CE2786E11341594LL, getclassnames) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionextension::getclassnames", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclassnames());
      }
      break;
    case 21:
      HASH_GUARD(0x306B5F4D1D03D335LL, getinientries) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionextension::getinientries", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinientries());
      }
      HASH_GUARD(0x1CC71CB013143955LL, getconstants) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionextension::getconstants", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getconstants());
      }
      break;
    case 22:
      HASH_GUARD(0x7521E8833BE3D316LL, getversion) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionextension::getversion", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getversion());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionextension::__construct", count, 1, 1, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      HASH_GUARD(0x0F2EF58F157D479FLL, info) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionextension::info", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_info());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_reflectionextension::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("reflectionextension::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_reflectionextension = {
  c_reflectionextension::os_getInit,
  c_reflectionextension::os_get,
  c_reflectionextension::os_lval,
  c_reflectionextension::os_invoke,
  c_reflectionextension::os_constant,
};
void c_reflectionextension::init() {
  m_name = null;
  m_info = null;
}
/* SRC: classes/reflection.php line 740 */
void c_reflectionextension::t___construct(Variant v_name) {
  INSTANCE_METHOD_INJECTION(ReflectionExtension, ReflectionExtension::__construct);
  bool oldInCtor = gasInCtor(true);
  (m_info = x_hphp_get_extension_info(toString(v_name)));
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/reflection.php line 744 */
String c_reflectionextension::t___tostring() {
  INSTANCE_METHOD_INJECTION(ReflectionExtension, ReflectionExtension::__toString);
  return toString(null);
} /* function */
/* SRC: classes/reflection.php line 747 */
Variant c_reflectionextension::ti_export(const char* cls, CVarRef v_name, CVarRef v_ret) {
  STATIC_METHOD_INJECTION(ReflectionExtension, ReflectionExtension::export);
  p_reflectionextension v_obj;
  String v_str;

  {
    c_reflectionextension *tmp79 = NEWOBJ(c_reflectionextension)();
    p_reflectionextension tmp80((p_reflectionextension(tmp79->create(v_name))));
    (v_obj = tmp80);
  }
  (v_str = (toString(v_obj)));
  if (toBoolean(v_ret)) {
    {
      return v_str;
    }
  }
  print(v_str);
  return null;
} /* function */
/* SRC: classes/reflection.php line 756 */
Variant c_reflectionextension::t_getname() {
  INSTANCE_METHOD_INJECTION(ReflectionExtension, ReflectionExtension::getName);
  return m_info.rvalAt("name", 0x0BCDB293DC3DBDDCLL, true, true);
} /* function */
/* SRC: classes/reflection.php line 760 */
Variant c_reflectionextension::t_getversion() {
  INSTANCE_METHOD_INJECTION(ReflectionExtension, ReflectionExtension::getVersion);
  return m_info.rvalAt("version", 0x2AF5F0847CD81DB4LL, true, true);
} /* function */
/* SRC: classes/reflection.php line 764 */
Variant c_reflectionextension::t_getfunctions() {
  INSTANCE_METHOD_INJECTION(ReflectionExtension, ReflectionExtension::getFunctions);
  return m_info.rvalAt("functions", 0x5BE59D9CB1CEB46DLL, true, true);
} /* function */
/* SRC: classes/reflection.php line 768 */
Variant c_reflectionextension::t_getconstants() {
  INSTANCE_METHOD_INJECTION(ReflectionExtension, ReflectionExtension::getConstants);
  return m_info.rvalAt("constants", 0x61A5DA894BD05406LL, true, true);
} /* function */
/* SRC: classes/reflection.php line 772 */
Variant c_reflectionextension::t_getinientries() {
  INSTANCE_METHOD_INJECTION(ReflectionExtension, ReflectionExtension::getINIEntries);
  return m_info.rvalAt("ini", 0x0A7D7869B87324F2LL, true, true);
} /* function */
/* SRC: classes/reflection.php line 776 */
Variant c_reflectionextension::t_getclasses() {
  INSTANCE_METHOD_INJECTION(ReflectionExtension, ReflectionExtension::getClasses);
  return m_info.rvalAt("classes", 0x6EF08968EDA9B7FBLL, true, true);
} /* function */
/* SRC: classes/reflection.php line 780 */
Array c_reflectionextension::t_getclassnames() {
  INSTANCE_METHOD_INJECTION(ReflectionExtension, ReflectionExtension::getClassNames);
  Array v_ret;
  Variant v_cls;

  (v_ret = SystemScalarArrays::ssa_[0]);
  {
    LOOP_COUNTER(81);
    Variant map82 = m_info.rvalAt("classes", 0x6EF08968EDA9B7FBLL, true, true);
    for (ArrayIterPtr iter83 = map82.begin("reflectionextension"); !iter83->end(); iter83->next()) {
      LOOP_COUNTER_CHECK(81);
      iter83->second(v_cls);
      {
        v_ret.append((v_cls. BIND_CLASS_DOT o_invoke_few_args("getName", 0x23F51CDECC198965LL, 0)));
      }
    }
  }
  return v_ret;
} /* function */
/* SRC: classes/reflection.php line 788 */
Variant c_reflectionextension::t_info() {
  INSTANCE_METHOD_INJECTION(ReflectionExtension, ReflectionExtension::info);
  return m_info.rvalAt("info", 0x3255DC7C4A035C47LL, true, true);
} /* function */
/* SRC: classes/reflection.php line 635 */
const int64 q_reflectionmethod_IS_STATIC = 1LL;
const int64 q_reflectionmethod_IS_PUBLIC = 256LL;
const int64 q_reflectionmethod_IS_PROTECTED = 512LL;
const int64 q_reflectionmethod_IS_PRIVATE = 1024LL;
const int64 q_reflectionmethod_IS_ABSTRACT = 2LL;
const int64 q_reflectionmethod_IS_FINAL = 4LL;
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionmethod
Variant c_reflectionmethod::os_getInit(const char *s, int64 hash) {
  DECLARE_SYSTEM_GLOBALS(g);
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 0:
      HASH_RETURN(0x0BCDB293DC3DBDDCLL, 
                  null, name);
      break;
    case 2:
      HASH_RETURN(0x45397FE5C82CBD12LL, 
                  null, class);
      break;
    default:
      break;
  }
  return c_reflectionfunctionabstract::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionmethod
Variant c_reflectionmethod::os_get(const char *s, int64 hash) {
  return c_reflectionfunctionabstract::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionmethod
Variant &c_reflectionmethod::os_lval(const char *s, int64 hash) {
  return c_reflectionfunctionabstract::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionmethod
void c_reflectionmethod::o_get(Array &props) const {
  if (isInitialized(m_name)) props.set("name", m_name.isReferenced() ? ref(m_name) : m_name, 0x0BCDB293DC3DBDDCLL, true);
  if (isInitialized(m_class)) props.set("class", m_class.isReferenced() ? ref(m_class) : m_class, 0x45397FE5C82CBD12LL, true);
  c_reflectionfunctionabstract::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_get_reflectionmethod
Variant c_reflectionmethod::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_reflectionmethod::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionmethod
Variant c_reflectionmethod::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 3) {
    case 0:
      HASH_RETURN_STRING(0x0BCDB293DC3DBDDCLL, m_name,
                         name, 4);
      break;
    case 2:
      HASH_RETURN_STRING(0x45397FE5C82CBD12LL, m_class,
                         class, 5);
      break;
    default:
      break;
  }
  return c_reflectionfunctionabstract::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionmethod
Variant c_reflectionmethod::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_exists_reflectionmethod
bool c_reflectionmethod::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_reflectionmethod::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionmethod
bool c_reflectionmethod::o_existsPublic(CStrRef s, int64 hash) const {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 3) {
    case 0:
      HASH_EXISTS_STRING(0x0BCDB293DC3DBDDCLL, name, 4);
      break;
    case 2:
      HASH_EXISTS_STRING(0x45397FE5C82CBD12LL, class, 5);
      break;
    default:
      break;
  }
  return c_reflectionfunctionabstract::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionmethod
bool c_reflectionmethod::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_set_reflectionmethod
Variant c_reflectionmethod::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_reflectionmethod::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionmethod
Variant c_reflectionmethod::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 3) {
    case 0:
      HASH_SET_STRING(0x0BCDB293DC3DBDDCLL, m_name,
                      name, 4);
      break;
    case 2:
      HASH_SET_STRING(0x45397FE5C82CBD12LL, m_class,
                      class, 5);
      break;
    default:
      break;
  }
  return c_reflectionfunctionabstract::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionmethod
Variant c_reflectionmethod::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_lval_reflectionmethod
Variant& c_reflectionmethod::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_reflectionmethod::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionmethod
Variant& c_reflectionmethod::o_lvalPublic(CStrRef s, int64 hash) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 3) {
    case 0:
      HASH_RETURN_STRING(0x0BCDB293DC3DBDDCLL, m_name,
                         name, 4);
      break;
    case 2:
      HASH_RETURN_STRING(0x45397FE5C82CBD12LL, m_class,
                         class, 5);
      break;
    default:
      break;
  }
  return c_reflectionfunctionabstract::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionmethod
Variant& c_reflectionmethod::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionmethod
Variant c_reflectionmethod::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_RETURN(0x163BE642CB04C741LL, q_reflectionmethod_IS_PRIVATE, IS_PRIVATE);
      break;
    case 3:
      HASH_RETURN(0x6572B785E302A373LL, q_reflectionmethod_IS_ABSTRACT, IS_ABSTRACT);
      break;
    case 4:
      HASH_RETURN(0x5F17AEF953553E24LL, q_reflectionmethod_IS_PUBLIC, IS_PUBLIC);
      break;
    case 6:
      HASH_RETURN(0x47AAFAC74A59AD66LL, q_reflectionmethod_IS_FINAL, IS_FINAL);
      break;
    case 7:
      HASH_RETURN(0x56142E71554B0647LL, q_reflectionmethod_IS_STATIC, IS_STATIC);
      HASH_RETURN(0x6912B8D6D8DE2FF7LL, q_reflectionmethod_IS_PROTECTED, IS_PROTECTED);
      break;
    default:
      break;
  }
  return c_reflectionfunctionabstract::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionmethod
IMPLEMENT_CLASS(reflectionmethod)
c_reflectionmethod *c_reflectionmethod::create(Variant v_cls, Variant v_name) {
  CountableHelper h(this);
  init();
  t___construct(v_cls, v_name);
  return this;
}
ObjectData *c_reflectionmethod::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("reflectionmethod::__construct", count, 2, 2, 2);
    (t___construct(params[0], params[1]));
  }
  return this;
}
void c_reflectionmethod::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("reflectionmethod::__construct", count, 2, 2, 2);
  (t___construct(params[0], params[1]));
}
void c_reflectionmethod::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("reflectionmethod::__construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0, a1), null);
}
ObjectData *c_reflectionmethod::cloneImpl() {
  c_reflectionmethod *obj = NEW(c_reflectionmethod)();
  cloneSet(obj);
  return obj;
}
void c_reflectionmethod::cloneSet(c_reflectionmethod *clone) {
  clone->m_name = m_name.isReferenced() ? ref(m_name) : m_name;
  clone->m_class = m_class.isReferenced() ? ref(m_class) : m_class;
  c_reflectionfunctionabstract::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionmethod
Variant c_reflectionmethod::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 2:
      HASH_GUARD(0x3FCE192CF6199942LL, invoke) {
        if (count < 1) return throw_missing_arguments("reflectionmethod::invoke", count+1, 1);
        if (count <= 1) return (t_invoke(count, params[0]));
        return (t_invoke(count,params[0], params.slice(1, count - 1, false)));
      }
      break;
    case 4:
      HASH_GUARD(0x3235AF57F23103C4LL, invokeargs) {
        if (count != 2) return throw_wrong_arguments("reflectionmethod::invokeargs", count, 2, 2, 1);
        return (t_invokeargs(params[0], params[1]));
      }
      HASH_GUARD(0x39C1BB731CB1CB04LL, getstartline) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
        return (t_getstartline());
      }
      break;
    case 7:
      HASH_GUARD(0x51A20EA0E327F607LL, isdestructor) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isdestructor", 0, 1);
        return (t_isdestructor());
      }
      break;
    case 13:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD(0x48FDF6C5835C64CFLL, isinternal) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x24253EBA491D6014LL, getmodifiers) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::getmodifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 25:
      HASH_GUARD(0x7A15DC56E8CC0B19LL, isstatic) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isstatic", 0, 1);
        return (t_isstatic());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 2) return throw_wrong_arguments("reflectionmethod::__construct", count, 2, 2, 2);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    case 32:
      HASH_GUARD(0x57D8DC34C9A03560LL, getnumberofparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 33:
      HASH_GUARD(0x4D637DECDBFA6221LL, getnumberofrequiredparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 34:
      HASH_GUARD(0x33A6C2CFBDB05EE2LL, getclosure) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::getclosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 35:
      HASH_GUARD(0x6ED51288559D6063LL, getdeclaringclass) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::getdeclaringclass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 36:
      HASH_GUARD(0x6A6B8BECAE7D4164LL, isuserdefined) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 37:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
        return (t_getname());
      }
      break;
    case 40:
      HASH_GUARD(0x37FFB8F44A3329A8LL, getstaticvariables) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
        return (t_getstaticvariables());
      }
      HASH_GUARD(0x1A3AB3B0276D2668LL, returnsreference) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
        return (t_returnsreference());
      }
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 3) return throw_wrong_arguments("reflectionmethod::export", count, 3, 3, 1);
        return (ti_export(o_getClassName(), params[0], params[1], params[2]));
      }
      break;
    case 42:
      HASH_GUARD(0x2D7209A590477CEALL, isprotected) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isprotected", 0, 1);
        return (t_isprotected());
      }
      break;
    case 45:
      HASH_GUARD(0x3E62225132C2A32DLL, getparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
        return (t_getparameters());
      }
      break;
    case 46:
      HASH_GUARD(0x06FB6A7DC3D795AELL, isfinal) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isfinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 47:
      HASH_GUARD(0x37AAE0845E2F636FLL, isprivate) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isprivate", 0, 1);
        return (t_isprivate());
      }
      break;
    case 48:
      HASH_GUARD(0x6C19E85007BC4570LL, getendline) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
        return (t_getendline());
      }
      break;
    case 55:
      HASH_GUARD(0x7460D945DA32FDB7LL, isabstract) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isabstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 56:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 58:
      HASH_GUARD(0x654B5F965C5CAC7ALL, isconstructor) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isconstructor", 0, 1);
        return (t_isconstructor());
      }
      break;
    case 60:
      HASH_GUARD(0x2820F10358723B7CLL, ispublic) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::ispublic", 0, 1);
        return (t_ispublic());
      }
      break;
    default:
      break;
  }
  return c_reflectionfunctionabstract::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionmethod
Variant c_reflectionmethod::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 2:
      HASH_GUARD(0x3FCE192CF6199942LL, invoke) {
        if (count < 1) return throw_missing_arguments("reflectionmethod::invoke", count+1, 1);
        if (count <= 1) return (t_invoke(count, a0));
        Array params;
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_invoke(count,a0, params));
      }
      break;
    case 4:
      HASH_GUARD(0x3235AF57F23103C4LL, invokeargs) {
        if (count != 2) return throw_wrong_arguments("reflectionmethod::invokeargs", count, 2, 2, 1);
        return (t_invokeargs(a0, a1));
      }
      HASH_GUARD(0x39C1BB731CB1CB04LL, getstartline) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
        return (t_getstartline());
      }
      break;
    case 7:
      HASH_GUARD(0x51A20EA0E327F607LL, isdestructor) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isdestructor", 0, 1);
        return (t_isdestructor());
      }
      break;
    case 13:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD(0x48FDF6C5835C64CFLL, isinternal) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x24253EBA491D6014LL, getmodifiers) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::getmodifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 25:
      HASH_GUARD(0x7A15DC56E8CC0B19LL, isstatic) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isstatic", 0, 1);
        return (t_isstatic());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 2) return throw_wrong_arguments("reflectionmethod::__construct", count, 2, 2, 2);
        return (t___construct(a0, a1), null);
      }
      break;
    case 32:
      HASH_GUARD(0x57D8DC34C9A03560LL, getnumberofparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 33:
      HASH_GUARD(0x4D637DECDBFA6221LL, getnumberofrequiredparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 34:
      HASH_GUARD(0x33A6C2CFBDB05EE2LL, getclosure) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::getclosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 35:
      HASH_GUARD(0x6ED51288559D6063LL, getdeclaringclass) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::getdeclaringclass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 36:
      HASH_GUARD(0x6A6B8BECAE7D4164LL, isuserdefined) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 37:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
        return (t_getname());
      }
      break;
    case 40:
      HASH_GUARD(0x37FFB8F44A3329A8LL, getstaticvariables) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
        return (t_getstaticvariables());
      }
      HASH_GUARD(0x1A3AB3B0276D2668LL, returnsreference) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
        return (t_returnsreference());
      }
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 3) return throw_wrong_arguments("reflectionmethod::export", count, 3, 3, 1);
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      break;
    case 42:
      HASH_GUARD(0x2D7209A590477CEALL, isprotected) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isprotected", 0, 1);
        return (t_isprotected());
      }
      break;
    case 45:
      HASH_GUARD(0x3E62225132C2A32DLL, getparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
        return (t_getparameters());
      }
      break;
    case 46:
      HASH_GUARD(0x06FB6A7DC3D795AELL, isfinal) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isfinal", 0, 1);
        return (t_isfinal());
      }
      break;
    case 47:
      HASH_GUARD(0x37AAE0845E2F636FLL, isprivate) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isprivate", 0, 1);
        return (t_isprivate());
      }
      break;
    case 48:
      HASH_GUARD(0x6C19E85007BC4570LL, getendline) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
        return (t_getendline());
      }
      break;
    case 55:
      HASH_GUARD(0x7460D945DA32FDB7LL, isabstract) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isabstract", 0, 1);
        return (t_isabstract());
      }
      break;
    case 56:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 58:
      HASH_GUARD(0x654B5F965C5CAC7ALL, isconstructor) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isconstructor", 0, 1);
        return (t_isconstructor());
      }
      break;
    case 60:
      HASH_GUARD(0x2820F10358723B7CLL, ispublic) {
        if (count > 0) return throw_toomany_arguments("reflectionmethod::ispublic", 0, 1);
        return (t_ispublic());
      }
      break;
    default:
      break;
  }
  return c_reflectionfunctionabstract::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionmethod
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionmethod
Variant c_reflectionmethod::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 3) return throw_wrong_arguments("reflectionmethod::export", count, 3, 3, 1);
        return (ti_export(c, params[0], params[1], params[2]));
      }
      break;
    default:
      break;
  }
  return c_reflectionfunctionabstract::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionmethod
Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 2:
      HASH_GUARD(0x3FCE192CF6199942LL, invoke) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("reflectionmethod::invoke", count+1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 1) return (t_invoke(count, a0));
        return (t_invoke(count, a0,vargs));
      }
      break;
    case 4:
      HASH_GUARD(0x3235AF57F23103C4LL, invokeargs) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("reflectionmethod::invokeargs", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_invokeargs(a0, a1));
      }
      HASH_GUARD(0x39C1BB731CB1CB04LL, getstartline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstartline());
      }
      break;
    case 7:
      HASH_GUARD(0x51A20EA0E327F607LL, isdestructor) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isdestructor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdestructor());
      }
      break;
    case 13:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD(0x48FDF6C5835C64CFLL, isinternal) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinternal());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionmethod::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x24253EBA491D6014LL, getmodifiers) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionmethod::getmodifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmodifiers());
      }
      break;
    case 25:
      HASH_GUARD(0x7A15DC56E8CC0B19LL, isstatic) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isstatic", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isstatic());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("reflectionmethod::__construct", count, 2, 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    case 32:
      HASH_GUARD(0x57D8DC34C9A03560LL, getnumberofparameters) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofparameters());
      }
      break;
    case 33:
      HASH_GUARD(0x4D637DECDBFA6221LL, getnumberofrequiredparameters) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 34:
      HASH_GUARD(0x33A6C2CFBDB05EE2LL, getclosure) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionmethod::getclosure", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclosure());
      }
      break;
    case 35:
      HASH_GUARD(0x6ED51288559D6063LL, getdeclaringclass) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionmethod::getdeclaringclass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdeclaringclass());
      }
      break;
    case 36:
      HASH_GUARD(0x6A6B8BECAE7D4164LL, isuserdefined) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isuserdefined());
      }
      break;
    case 37:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 40:
      HASH_GUARD(0x37FFB8F44A3329A8LL, getstaticvariables) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstaticvariables());
      }
      HASH_GUARD(0x1A3AB3B0276D2668LL, returnsreference) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_returnsreference());
      }
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("reflectionmethod::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      break;
    case 42:
      HASH_GUARD(0x2D7209A590477CEALL, isprotected) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isprotected", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isprotected());
      }
      break;
    case 45:
      HASH_GUARD(0x3E62225132C2A32DLL, getparameters) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getparameters());
      }
      break;
    case 46:
      HASH_GUARD(0x06FB6A7DC3D795AELL, isfinal) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isfinal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isfinal());
      }
      break;
    case 47:
      HASH_GUARD(0x37AAE0845E2F636FLL, isprivate) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isprivate", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isprivate());
      }
      break;
    case 48:
      HASH_GUARD(0x6C19E85007BC4570LL, getendline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getendline());
      }
      break;
    case 55:
      HASH_GUARD(0x7460D945DA32FDB7LL, isabstract) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isabstract", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isabstract());
      }
      break;
    case 56:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    case 58:
      HASH_GUARD(0x654B5F965C5CAC7ALL, isconstructor) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionmethod::isconstructor", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isconstructor());
      }
      break;
    case 60:
      HASH_GUARD(0x2820F10358723B7CLL, ispublic) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionmethod::ispublic", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_ispublic());
      }
      break;
    default:
      break;
  }
  return c_reflectionfunctionabstract::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_reflectionmethod::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("reflectionmethod::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1, a2));
      }
      break;
    default:
      break;
  }
  return c_reflectionfunctionabstract::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_reflectionmethod = {
  c_reflectionmethod::os_getInit,
  c_reflectionmethod::os_get,
  c_reflectionmethod::os_lval,
  c_reflectionmethod::os_invoke,
  c_reflectionmethod::os_constant,
};
void c_reflectionmethod::init() {
  c_reflectionfunctionabstract::init();
  m_name = null;
  m_class = null;
}
/* SRC: classes/reflection.php line 647 */
void c_reflectionmethod::t___construct(Variant v_cls, Variant v_name) {
  INSTANCE_METHOD_INJECTION(ReflectionMethod, ReflectionMethod::__construct);
  bool oldInCtor = gasInCtor(true);
  Variant v_method;

  if (toBoolean(v_cls) && toBoolean(v_name)) {
    {
      if (!(x_is_object(v_cls))) {
        {
          c_reflectionclass *tmp84 = NEWOBJ(c_reflectionclass)();
          p_reflectionclass tmp85((p_reflectionclass(tmp84->create(v_cls))));
          (v_cls = tmp85);
        }
      }
      {
        Variant tmp86((v_cls. BIND_CLASS_DOT o_invoke_few_args("getMethod", 0x0D81ECE253A3B5B6LL, 1, v_name)));
        (v_method = tmp86);
      }
      if (toBoolean(v_method)) {
        {
          (m_info = v_method.o_get("info", 0x3255DC7C4A035C47LL));
          (m_name = v_method.o_get("name", 0x0BCDB293DC3DBDDCLL));
          (m_class = v_method.o_get("class", 0x45397FE5C82CBD12LL));
        }
      }
    }
  }
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/reflection.php line 659 */
String c_reflectionmethod::t___tostring() {
  INSTANCE_METHOD_INJECTION(ReflectionMethod, ReflectionMethod::__toString);
  return toString(null);
} /* function */
/* SRC: classes/reflection.php line 663 */
Variant c_reflectionmethod::ti_export(const char* cls, Variant v_cls, CVarRef v_name, CVarRef v_ret) {
  STATIC_METHOD_INJECTION(ReflectionMethod, ReflectionMethod::export);
  Variant v_obj;
  String v_str;

  if (!(x_is_object(v_cls))) {
    {
      c_reflectionclass *tmp87 = NEWOBJ(c_reflectionclass)();
      p_reflectionclass tmp88((p_reflectionclass(tmp87->create(v_cls))));
      (v_cls = tmp88);
    }
  }
  {
    Variant tmp89((v_cls. BIND_CLASS_DOT o_invoke_few_args("getMethod", 0x0D81ECE253A3B5B6LL, 1, v_name)));
    (v_obj = tmp89);
  }
  (v_str = (toString(v_obj)));
  if (toBoolean(v_ret)) {
    {
      return v_str;
    }
  }
  print(v_str);
  return null;
} /* function */
/* SRC: classes/reflection.php line 673 */
Variant c_reflectionmethod::t_invoke(int num_args, CVarRef v_obj, Array args /* = Array() */) {
  INSTANCE_METHOD_INJECTION(ReflectionMethod, ReflectionMethod::invoke);
  Variant v_args;

  {
    const Array &tmp90((func_get_args(num_args, Array(ArrayInit(1, true).set(0, v_obj).create()),args)));
    (v_args = tmp90);
  }
  x_array_shift(ref(v_args));
  {
    Variant tmp91((v_obj));
    String tmp92((toString(m_info.rvalAt("class", 0x45397FE5C82CBD12LL, true, true))));
    String tmp93((toString(m_info.rvalAt("name", 0x0BCDB293DC3DBDDCLL, true, true))));
    return x_hphp_invoke_method(tmp91, tmp92, tmp93, toArray(v_args));
  }
} /* function */
/* SRC: classes/reflection.php line 680 */
Variant c_reflectionmethod::t_invokeargs(CVarRef v_obj, CVarRef v_args) {
  INSTANCE_METHOD_INJECTION(ReflectionMethod, ReflectionMethod::invokeArgs);
  {
    Variant tmp94((v_obj));
    String tmp95((toString(m_info.rvalAt("class", 0x45397FE5C82CBD12LL, true, true))));
    String tmp96((toString(m_info.rvalAt("name", 0x0BCDB293DC3DBDDCLL, true, true))));
    const Array &tmp97((toArray(x_array_values(v_args))));
    return x_hphp_invoke_method(tmp94, tmp95, tmp96, tmp97);
  }
} /* function */
/* SRC: classes/reflection.php line 685 */
Variant c_reflectionmethod::t_isfinal() {
  INSTANCE_METHOD_INJECTION(ReflectionMethod, ReflectionMethod::isFinal);
  return m_info.rvalAt("final", 0x5192930B2145036ELL, true, true);
} /* function */
/* SRC: classes/reflection.php line 689 */
Variant c_reflectionmethod::t_isabstract() {
  INSTANCE_METHOD_INJECTION(ReflectionMethod, ReflectionMethod::isAbstract);
  return m_info.rvalAt("abstract", 0x475C06CE12C8A8A6LL, true, true);
} /* function */
/* SRC: classes/reflection.php line 693 */
bool c_reflectionmethod::t_ispublic() {
  INSTANCE_METHOD_INJECTION(ReflectionMethod, ReflectionMethod::isPublic);
  return equal(m_info.rvalAt("access", 0x432ABF90750DDA3BLL, true, true), "public");
} /* function */
/* SRC: classes/reflection.php line 697 */
bool c_reflectionmethod::t_isprivate() {
  INSTANCE_METHOD_INJECTION(ReflectionMethod, ReflectionMethod::isPrivate);
  return equal(m_info.rvalAt("access", 0x432ABF90750DDA3BLL, true, true), "private");
} /* function */
/* SRC: classes/reflection.php line 701 */
bool c_reflectionmethod::t_isprotected() {
  INSTANCE_METHOD_INJECTION(ReflectionMethod, ReflectionMethod::isProtected);
  return equal(m_info.rvalAt("access", 0x432ABF90750DDA3BLL, true, true), "protected");
} /* function */
/* SRC: classes/reflection.php line 705 */
Variant c_reflectionmethod::t_isstatic() {
  INSTANCE_METHOD_INJECTION(ReflectionMethod, ReflectionMethod::isStatic);
  return m_info.rvalAt("static", 0x77C3F61406F7F174LL, true, true);
} /* function */
/* SRC: classes/reflection.php line 709 */
bool c_reflectionmethod::t_isconstructor() {
  INSTANCE_METHOD_INJECTION(ReflectionMethod, ReflectionMethod::isConstructor);
  return equal(t_getname(), "__construct");
} /* function */
/* SRC: classes/reflection.php line 713 */
bool c_reflectionmethod::t_isdestructor() {
  INSTANCE_METHOD_INJECTION(ReflectionMethod, ReflectionMethod::isDestructor);
  return equal(t_getname(), "__destruct");
} /* function */
/* SRC: classes/reflection.php line 717 */
Variant c_reflectionmethod::t_getmodifiers() {
  INSTANCE_METHOD_INJECTION(ReflectionMethod, ReflectionMethod::getModifiers);
  return m_info.rvalAt("modifiers", 0x2CAF244C9F244C80LL, true, true);
} /* function */
/* SRC: classes/reflection.php line 721 */
Variant c_reflectionmethod::t_getclosure() {
  INSTANCE_METHOD_INJECTION(ReflectionMethod, ReflectionMethod::getClosure);
  return m_info.rvalAt("closure", 0x3828EA96366C415ALL, true, true);
} /* function */
/* SRC: classes/reflection.php line 725 */
Variant c_reflectionmethod::t_getdeclaringclass() {
  INSTANCE_METHOD_INJECTION(ReflectionMethod, ReflectionMethod::getDeclaringClass);
  if (empty(m_info, "class", 0x45397FE5C82CBD12LL, true)) {
    {
      return null;
    }
  }
  {
    c_reflectionclass *tmp98 = NEWOBJ(c_reflectionclass)();
    return p_reflectionclass(tmp98->create(m_info.rvalAt("class", 0x45397FE5C82CBD12LL, true, true)));
  }
} /* function */
/* SRC: classes/reflection.php line 534 */
const int64 q_reflectionproperty_IS_STATIC = 1LL;
const int64 q_reflectionproperty_IS_PUBLIC = 256LL;
const int64 q_reflectionproperty_IS_PROTECTED = 512LL;
const int64 q_reflectionproperty_IS_PRIVATE = 1024LL;
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionproperty
Variant c_reflectionproperty::os_getInit(const char *s, int64 hash) {
  DECLARE_SYSTEM_GLOBALS(g);
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_RETURN(0x45397FE5C82CBD12LL, 
                  null, class);
      break;
    case 4:
      HASH_RETURN(0x0BCDB293DC3DBDDCLL, 
                  null, name);
      break;
    case 7:
      HASH_RETURN(0x3255DC7C4A035C47LL, 
                  null, info);
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionproperty
Variant c_reflectionproperty::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionproperty
Variant &c_reflectionproperty::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionproperty
void c_reflectionproperty::o_get(Array &props) const {
  if (isInitialized(m_info)) props.set("info", m_info.isReferenced() ? ref(m_info) : m_info, 0x3255DC7C4A035C47LL, true);
  if (isInitialized(m_name)) props.set("name", m_name.isReferenced() ? ref(m_name) : m_name, 0x0BCDB293DC3DBDDCLL, true);
  if (isInitialized(m_class)) props.set("class", m_class.isReferenced() ? ref(m_class) : m_class, 0x45397FE5C82CBD12LL, true);
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_get_reflectionproperty
Variant c_reflectionproperty::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_reflectionproperty::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionproperty
Variant c_reflectionproperty::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 7) {
    case 2:
      HASH_RETURN_STRING(0x45397FE5C82CBD12LL, m_class,
                         class, 5);
      break;
    case 4:
      HASH_RETURN_STRING(0x0BCDB293DC3DBDDCLL, m_name,
                         name, 4);
      break;
    case 7:
      HASH_RETURN_STRING(0x3255DC7C4A035C47LL, m_info,
                         info, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionproperty
Variant c_reflectionproperty::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_exists_reflectionproperty
bool c_reflectionproperty::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_reflectionproperty::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionproperty
bool c_reflectionproperty::o_existsPublic(CStrRef s, int64 hash) const {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 7) {
    case 2:
      HASH_EXISTS_STRING(0x45397FE5C82CBD12LL, class, 5);
      break;
    case 4:
      HASH_EXISTS_STRING(0x0BCDB293DC3DBDDCLL, name, 4);
      break;
    case 7:
      HASH_EXISTS_STRING(0x3255DC7C4A035C47LL, info, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionproperty
bool c_reflectionproperty::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_set_reflectionproperty
Variant c_reflectionproperty::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_reflectionproperty::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionproperty
Variant c_reflectionproperty::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 7) {
    case 2:
      HASH_SET_STRING(0x45397FE5C82CBD12LL, m_class,
                      class, 5);
      break;
    case 4:
      HASH_SET_STRING(0x0BCDB293DC3DBDDCLL, m_name,
                      name, 4);
      break;
    case 7:
      HASH_SET_STRING(0x3255DC7C4A035C47LL, m_info,
                      info, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionproperty
Variant c_reflectionproperty::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_lval_reflectionproperty
Variant& c_reflectionproperty::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_reflectionproperty::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionproperty
Variant& c_reflectionproperty::o_lvalPublic(CStrRef s, int64 hash) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 7) {
    case 2:
      HASH_RETURN_STRING(0x45397FE5C82CBD12LL, m_class,
                         class, 5);
      break;
    case 4:
      HASH_RETURN_STRING(0x0BCDB293DC3DBDDCLL, m_name,
                         name, 4);
      break;
    case 7:
      HASH_RETURN_STRING(0x3255DC7C4A035C47LL, m_info,
                         info, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionproperty
Variant& c_reflectionproperty::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionproperty
Variant c_reflectionproperty::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 7) {
    case 1:
      HASH_RETURN(0x163BE642CB04C741LL, q_reflectionproperty_IS_PRIVATE, IS_PRIVATE);
      break;
    case 4:
      HASH_RETURN(0x5F17AEF953553E24LL, q_reflectionproperty_IS_PUBLIC, IS_PUBLIC);
      break;
    case 7:
      HASH_RETURN(0x56142E71554B0647LL, q_reflectionproperty_IS_STATIC, IS_STATIC);
      HASH_RETURN(0x6912B8D6D8DE2FF7LL, q_reflectionproperty_IS_PROTECTED, IS_PROTECTED);
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionproperty
IMPLEMENT_CLASS(reflectionproperty)
c_reflectionproperty *c_reflectionproperty::create(Variant v_cls, Variant v_name) {
  CountableHelper h(this);
  init();
  t___construct(v_cls, v_name);
  return this;
}
ObjectData *c_reflectionproperty::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("reflectionproperty::__construct", count, 2, 2, 2);
    (t___construct(params[0], params[1]));
  }
  return this;
}
void c_reflectionproperty::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("reflectionproperty::__construct", count, 2, 2, 2);
  (t___construct(params[0], params[1]));
}
void c_reflectionproperty::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("reflectionproperty::__construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0, a1), null);
}
ObjectData *c_reflectionproperty::cloneImpl() {
  c_reflectionproperty *obj = NEW(c_reflectionproperty)();
  cloneSet(obj);
  return obj;
}
void c_reflectionproperty::cloneSet(c_reflectionproperty *clone) {
  clone->m_info = m_info.isReferenced() ? ref(m_info) : m_info;
  clone->m_name = m_name.isReferenced() ? ref(m_name) : m_name;
  clone->m_class = m_class.isReferenced() ? ref(m_class) : m_class;
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionproperty
Variant c_reflectionproperty::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 2:
      HASH_GUARD(0x791E9751F5B8C5A2LL, setaccessible) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::setaccessible", 0, 1);
        return (t_setaccessible(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x56879BCEB40997E3LL, getvalue) {
        if (count > 1) return throw_toomany_arguments("reflectionproperty::getvalue", 1, 1);
        if (count <= 0) return (t_getvalue());
        return (t_getvalue(params[0]));
      }
      HASH_GUARD(0x6ED51288559D6063LL, getdeclaringclass) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::getdeclaringclass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::getname", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 3) return throw_wrong_arguments("reflectionproperty::export", count, 3, 3, 1);
        return (ti_export(o_getClassName(), params[0], params[1], params[2]));
      }
      break;
    case 10:
      HASH_GUARD(0x2D7209A590477CEALL, isprotected) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::isprotected", 0, 1);
        return (t_isprotected());
      }
      break;
    case 15:
      HASH_GUARD(0x37AAE0845E2F636FLL, isprivate) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::isprivate", 0, 1);
        return (t_isprivate());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x24253EBA491D6014LL, getmodifiers) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::getmodifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 21:
      HASH_GUARD(0x384A52597AB11F15LL, isdefault) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::isdefault", 0, 1);
        return (t_isdefault());
      }
      HASH_GUARD(0x36FBED35008C8DB5LL, setvalue) {
        if (count != 2) return throw_wrong_arguments("reflectionproperty::setvalue", count, 2, 2, 1);
        return (t_setvalue(params[0], params[1]));
      }
      break;
    case 24:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::getdoccomment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 25:
      HASH_GUARD(0x7A15DC56E8CC0B19LL, isstatic) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::isstatic", 0, 1);
        return (t_isstatic());
      }
      break;
    case 28:
      HASH_GUARD(0x2820F10358723B7CLL, ispublic) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::ispublic", 0, 1);
        return (t_ispublic());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 2) return throw_wrong_arguments("reflectionproperty::__construct", count, 2, 2, 2);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionproperty
Variant c_reflectionproperty::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 2:
      HASH_GUARD(0x791E9751F5B8C5A2LL, setaccessible) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::setaccessible", 0, 1);
        return (t_setaccessible(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x56879BCEB40997E3LL, getvalue) {
        if (count > 1) return throw_toomany_arguments("reflectionproperty::getvalue", 1, 1);
        if (count <= 0) return (t_getvalue());
        return (t_getvalue(a0));
      }
      HASH_GUARD(0x6ED51288559D6063LL, getdeclaringclass) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::getdeclaringclass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::getname", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 3) return throw_wrong_arguments("reflectionproperty::export", count, 3, 3, 1);
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      break;
    case 10:
      HASH_GUARD(0x2D7209A590477CEALL, isprotected) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::isprotected", 0, 1);
        return (t_isprotected());
      }
      break;
    case 15:
      HASH_GUARD(0x37AAE0845E2F636FLL, isprivate) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::isprivate", 0, 1);
        return (t_isprivate());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x24253EBA491D6014LL, getmodifiers) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::getmodifiers", 0, 1);
        return (t_getmodifiers());
      }
      break;
    case 21:
      HASH_GUARD(0x384A52597AB11F15LL, isdefault) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::isdefault", 0, 1);
        return (t_isdefault());
      }
      HASH_GUARD(0x36FBED35008C8DB5LL, setvalue) {
        if (count != 2) return throw_wrong_arguments("reflectionproperty::setvalue", count, 2, 2, 1);
        return (t_setvalue(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::getdoccomment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    case 25:
      HASH_GUARD(0x7A15DC56E8CC0B19LL, isstatic) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::isstatic", 0, 1);
        return (t_isstatic());
      }
      break;
    case 28:
      HASH_GUARD(0x2820F10358723B7CLL, ispublic) {
        if (count > 0) return throw_toomany_arguments("reflectionproperty::ispublic", 0, 1);
        return (t_ispublic());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 2) return throw_wrong_arguments("reflectionproperty::__construct", count, 2, 2, 2);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionproperty
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionproperty
Variant c_reflectionproperty::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 3) return throw_wrong_arguments("reflectionproperty::export", count, 3, 3, 1);
        return (ti_export(c, params[0], params[1], params[2]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionproperty
Variant c_reflectionproperty::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 2:
      HASH_GUARD(0x791E9751F5B8C5A2LL, setaccessible) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionproperty::setaccessible", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setaccessible(), null);
      }
      break;
    case 3:
      HASH_GUARD(0x56879BCEB40997E3LL, getvalue) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("reflectionproperty::getvalue", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getvalue());
        else return (t_getvalue(a0));
      }
      HASH_GUARD(0x6ED51288559D6063LL, getdeclaringclass) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionproperty::getdeclaringclass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdeclaringclass());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionproperty::getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("reflectionproperty::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      break;
    case 10:
      HASH_GUARD(0x2D7209A590477CEALL, isprotected) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionproperty::isprotected", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isprotected());
      }
      break;
    case 15:
      HASH_GUARD(0x37AAE0845E2F636FLL, isprivate) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionproperty::isprivate", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isprivate());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionproperty::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD(0x24253EBA491D6014LL, getmodifiers) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionproperty::getmodifiers", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmodifiers());
      }
      break;
    case 21:
      HASH_GUARD(0x384A52597AB11F15LL, isdefault) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionproperty::isdefault", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefault());
      }
      HASH_GUARD(0x36FBED35008C8DB5LL, setvalue) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("reflectionproperty::setvalue", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setvalue(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionproperty::getdoccomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    case 25:
      HASH_GUARD(0x7A15DC56E8CC0B19LL, isstatic) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionproperty::isstatic", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isstatic());
      }
      break;
    case 28:
      HASH_GUARD(0x2820F10358723B7CLL, ispublic) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionproperty::ispublic", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_ispublic());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("reflectionproperty::__construct", count, 2, 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_reflectionproperty::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("reflectionproperty::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1, a2));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_reflectionproperty = {
  c_reflectionproperty::os_getInit,
  c_reflectionproperty::os_get,
  c_reflectionproperty::os_lval,
  c_reflectionproperty::os_invoke,
  c_reflectionproperty::os_constant,
};
void c_reflectionproperty::init() {
  m_info = null;
  m_name = null;
  m_class = null;
}
/* SRC: classes/reflection.php line 544 */
void c_reflectionproperty::t___construct(Variant v_cls, Variant v_name) {
  INSTANCE_METHOD_INJECTION(ReflectionProperty, ReflectionProperty::__construct);
  bool oldInCtor = gasInCtor(true);
  Variant v_prop;

  if (toBoolean(v_cls) && toBoolean(v_name)) {
    {
      if (!(x_is_object(v_cls))) {
        {
          c_reflectionclass *tmp99 = NEWOBJ(c_reflectionclass)();
          p_reflectionclass tmp100((p_reflectionclass(tmp99->create(v_cls))));
          (v_cls = tmp100);
        }
      }
      {
        Variant tmp101((v_cls. BIND_CLASS_DOT o_invoke_few_args("getProperty", 0x0FD73627FB023047LL, 1, v_name)));
        (v_prop = tmp101);
      }
      if (toBoolean(v_prop)) {
        {
          (m_info = v_prop.o_get("info", 0x3255DC7C4A035C47LL));
          (m_name = v_prop.o_get("name", 0x0BCDB293DC3DBDDCLL));
          (m_class = v_prop.o_get("class", 0x45397FE5C82CBD12LL));
        }
      }
    }
  }
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/reflection.php line 556 */
String c_reflectionproperty::t___tostring() {
  INSTANCE_METHOD_INJECTION(ReflectionProperty, ReflectionProperty::__toString);
  return toString(null);
} /* function */
/* SRC: classes/reflection.php line 559 */
Variant c_reflectionproperty::ti_export(const char* cls, Variant v_cls, CVarRef v_name, CVarRef v_ret) {
  STATIC_METHOD_INJECTION(ReflectionProperty, ReflectionProperty::export);
  Variant v_obj;
  String v_str;

  if (!(x_is_object(v_cls))) {
    {
      c_reflectionclass *tmp102 = NEWOBJ(c_reflectionclass)();
      p_reflectionclass tmp103((p_reflectionclass(tmp102->create(v_cls))));
      (v_cls = tmp103);
    }
  }
  {
    Variant tmp104((v_cls. BIND_CLASS_DOT o_invoke_few_args("getProperty", 0x0FD73627FB023047LL, 1, v_name)));
    (v_obj = tmp104);
  }
  (v_str = (toString(v_obj)));
  if (toBoolean(v_ret)) {
    {
      return v_str;
    }
  }
  print(v_str);
  return null;
} /* function */
/* SRC: classes/reflection.php line 569 */
Variant c_reflectionproperty::t_getname() {
  INSTANCE_METHOD_INJECTION(ReflectionProperty, ReflectionProperty::getName);
  return m_info.rvalAt("name", 0x0BCDB293DC3DBDDCLL, true, true);
} /* function */
/* SRC: classes/reflection.php line 573 */
bool c_reflectionproperty::t_ispublic() {
  INSTANCE_METHOD_INJECTION(ReflectionProperty, ReflectionProperty::isPublic);
  return equal(m_info.rvalAt("access", 0x432ABF90750DDA3BLL, true, true), "public");
} /* function */
/* SRC: classes/reflection.php line 577 */
bool c_reflectionproperty::t_isprivate() {
  INSTANCE_METHOD_INJECTION(ReflectionProperty, ReflectionProperty::isPrivate);
  return equal(m_info.rvalAt("access", 0x432ABF90750DDA3BLL, true, true), "private");
} /* function */
/* SRC: classes/reflection.php line 581 */
bool c_reflectionproperty::t_isprotected() {
  INSTANCE_METHOD_INJECTION(ReflectionProperty, ReflectionProperty::isProtected);
  return equal(m_info.rvalAt("access", 0x432ABF90750DDA3BLL, true, true), "protected");
} /* function */
/* SRC: classes/reflection.php line 585 */
Variant c_reflectionproperty::t_isstatic() {
  INSTANCE_METHOD_INJECTION(ReflectionProperty, ReflectionProperty::isStatic);
  return m_info.rvalAt("static", 0x77C3F61406F7F174LL, true, true);
} /* function */
/* SRC: classes/reflection.php line 589 */
Variant c_reflectionproperty::t_isdefault() {
  INSTANCE_METHOD_INJECTION(ReflectionProperty, ReflectionProperty::isDefault);
  return m_info.rvalAt("default", 0x1575CB56409781E3LL, true, true);
} /* function */
/* SRC: classes/reflection.php line 593 */
void c_reflectionproperty::t_setaccessible() {
  INSTANCE_METHOD_INJECTION(ReflectionProperty, ReflectionProperty::setAccessible);
} /* function */
/* SRC: classes/reflection.php line 596 */
Variant c_reflectionproperty::t_getmodifiers() {
  INSTANCE_METHOD_INJECTION(ReflectionProperty, ReflectionProperty::getModifiers);
  return m_info.rvalAt("modifiers", 0x2CAF244C9F244C80LL, true, true);
} /* function */
/* SRC: classes/reflection.php line 600 */
Variant c_reflectionproperty::t_getvalue(CVarRef v_obj //  = null_variant
) {
  INSTANCE_METHOD_INJECTION(ReflectionProperty, ReflectionProperty::getValue);
  if (toBoolean(t_isstatic())) {
    {
      {
        String tmp105((toString(m_info.rvalAt("class", 0x45397FE5C82CBD12LL, true, true))));
        return x_hphp_get_static_property(tmp105, toString(m_info.rvalAt("name", 0x0BCDB293DC3DBDDCLL, true, true)));
      }
    }
  }
  if (toBoolean(v_obj)) {
    {
      {
        Object tmp106((toObject(v_obj)));
        String tmp107((toString(m_info.rvalAt("class", 0x45397FE5C82CBD12LL, true, true))));
        String tmp108((toString(m_info.rvalAt("name", 0x0BCDB293DC3DBDDCLL, true, true))));
        return x_hphp_get_property(tmp106, tmp107, tmp108);
      }
    }
  }
  return null;
} /* function */
/* SRC: classes/reflection.php line 612 */
Variant c_reflectionproperty::t_setvalue(CVarRef v_obj, CVarRef v_value) {
  INSTANCE_METHOD_INJECTION(ReflectionProperty, ReflectionProperty::setValue);
  if (toBoolean(t_isstatic())) {
    {
      {
        String tmp109((toString(m_info.rvalAt("class", 0x45397FE5C82CBD12LL, true, true))));
        String tmp110((toString(m_info.rvalAt("name", 0x0BCDB293DC3DBDDCLL, true, true))));
        return (x_hphp_set_static_property(tmp109, tmp110, v_value), null);
      }
    }
  }
  {
    Object tmp111((toObject(v_obj)));
    String tmp112((toString(m_info.rvalAt("class", 0x45397FE5C82CBD12LL, true, true))));
    String tmp113((toString(m_info.rvalAt("name", 0x0BCDB293DC3DBDDCLL, true, true))));
    x_hphp_set_property(tmp111, tmp112, tmp113, v_value);
  }
  return null;
} /* function */
/* SRC: classes/reflection.php line 620 */
Variant c_reflectionproperty::t_getdeclaringclass() {
  INSTANCE_METHOD_INJECTION(ReflectionProperty, ReflectionProperty::getDeclaringClass);
  if (empty(m_info, "class", 0x45397FE5C82CBD12LL, true)) {
    {
      return null;
    }
  }
  {
    c_reflectionclass *tmp114 = NEWOBJ(c_reflectionclass)();
    return p_reflectionclass(tmp114->create(m_info.rvalAt("class", 0x45397FE5C82CBD12LL, true, true)));
  }
} /* function */
/* SRC: classes/reflection.php line 627 */
Variant c_reflectionproperty::t_getdoccomment() {
  INSTANCE_METHOD_INJECTION(ReflectionProperty, ReflectionProperty::getDocComment);
  return m_info.rvalAt("doc", 0x3E08E8478690475CLL, true, true);
} /* function */
/* SRC: classes/reflection.php line 165 */
const int64 q_reflectionfunction_IS_DEPRECATED = 262144LL;
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionfunction
Variant c_reflectionfunction::os_getInit(const char *s, int64 hash) {
  return c_reflectionfunctionabstract::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionfunction
Variant c_reflectionfunction::os_get(const char *s, int64 hash) {
  return c_reflectionfunctionabstract::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionfunction
Variant &c_reflectionfunction::os_lval(const char *s, int64 hash) {
  return c_reflectionfunctionabstract::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionfunction
void c_reflectionfunction::o_get(Array &props) const {
  c_reflectionfunctionabstract::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_get_reflectionfunction
Variant c_reflectionfunction::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_reflectionfunction::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionfunction
Variant c_reflectionfunction::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  return c_reflectionfunctionabstract::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionfunction
Variant c_reflectionfunction::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_exists_reflectionfunction
bool c_reflectionfunction::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_reflectionfunction::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionfunction
bool c_reflectionfunction::o_existsPublic(CStrRef s, int64 hash) const {
  return c_reflectionfunctionabstract::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionfunction
bool c_reflectionfunction::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_set_reflectionfunction
Variant c_reflectionfunction::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_reflectionfunction::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionfunction
Variant c_reflectionfunction::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return c_reflectionfunctionabstract::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionfunction
Variant c_reflectionfunction::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_lval_reflectionfunction
Variant& c_reflectionfunction::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_reflectionfunction::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionfunction
Variant& c_reflectionfunction::o_lvalPublic(CStrRef s, int64 hash) {
  return c_reflectionfunctionabstract::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionfunction
Variant& c_reflectionfunction::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionfunction
Variant c_reflectionfunction::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 1) {
    case 1:
      HASH_RETURN(0x7E324BF544E5B919LL, q_reflectionfunction_IS_DEPRECATED, IS_DEPRECATED);
      break;
    default:
      break;
  }
  return c_reflectionfunctionabstract::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionfunction
IMPLEMENT_CLASS(reflectionfunction)
c_reflectionfunction *c_reflectionfunction::create(Variant v_name) {
  CountableHelper h(this);
  init();
  t___construct(v_name);
  return this;
}
ObjectData *c_reflectionfunction::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("reflectionfunction::__construct", count, 1, 1, 2);
    (t___construct(params[0]));
  }
  return this;
}
void c_reflectionfunction::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("reflectionfunction::__construct", count, 1, 1, 2);
  (t___construct(params[0]));
}
void c_reflectionfunction::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("reflectionfunction::__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
ObjectData *c_reflectionfunction::cloneImpl() {
  c_reflectionfunction *obj = NEW(c_reflectionfunction)();
  cloneSet(obj);
  return obj;
}
void c_reflectionfunction::cloneSet(c_reflectionfunction *clone) {
  c_reflectionfunctionabstract::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionfunction
Variant c_reflectionfunction::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 2:
      HASH_GUARD(0x3FCE192CF6199942LL, invoke) {
        if (count <= 0) return (t_invoke(count));
        return (t_invoke(count,params.slice(0, count - 0, false)));
      }
      break;
    case 4:
      HASH_GUARD(0x3235AF57F23103C4LL, invokeargs) {
        if (count != 1) return throw_wrong_arguments("reflectionfunction::invokeargs", count, 1, 1, 1);
        return (t_invokeargs(params[0]));
      }
      HASH_GUARD(0x39C1BB731CB1CB04LL, getstartline) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
        return (t_getstartline());
      }
      break;
    case 13:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD(0x48FDF6C5835C64CFLL, isinternal) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("reflectionfunction::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("reflectionfunction::__construct", count, 1, 1, 2);
        return (t___construct(params[0]), null);
      }
      break;
    case 32:
      HASH_GUARD(0x57D8DC34C9A03560LL, getnumberofparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 33:
      HASH_GUARD(0x4D637DECDBFA6221LL, getnumberofrequiredparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 34:
      HASH_GUARD(0x33A6C2CFBDB05EE2LL, getclosure) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getclosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 36:
      HASH_GUARD(0x6A6B8BECAE7D4164LL, isuserdefined) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 37:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
        return (t_getname());
      }
      break;
    case 40:
      HASH_GUARD(0x37FFB8F44A3329A8LL, getstaticvariables) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
        return (t_getstaticvariables());
      }
      HASH_GUARD(0x1A3AB3B0276D2668LL, returnsreference) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
        return (t_returnsreference());
      }
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 2) return throw_wrong_arguments("reflectionfunction::export", count, 2, 2, 1);
        return (ti_export(o_getClassName(), params[0], params[1]));
      }
      break;
    case 45:
      HASH_GUARD(0x3E62225132C2A32DLL, getparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
        return (t_getparameters());
      }
      break;
    case 48:
      HASH_GUARD(0x6C19E85007BC4570LL, getendline) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
        return (t_getendline());
      }
      break;
    case 56:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    default:
      break;
  }
  return c_reflectionfunctionabstract::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionfunction
Variant c_reflectionfunction::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 2:
      HASH_GUARD(0x3FCE192CF6199942LL, invoke) {
        if (count <= 0) return (t_invoke(count));
        Array params;
        if (count >= 1) params.append(a0);
        if (count >= 2) params.append(a1);
        if (count >= 3) params.append(a2);
        if (count >= 4) params.append(a3);
        if (count >= 5) params.append(a4);
        if (count >= 6) params.append(a5);
        return (t_invoke(count,params));
      }
      break;
    case 4:
      HASH_GUARD(0x3235AF57F23103C4LL, invokeargs) {
        if (count != 1) return throw_wrong_arguments("reflectionfunction::invokeargs", count, 1, 1, 1);
        return (t_invokeargs(a0));
      }
      HASH_GUARD(0x39C1BB731CB1CB04LL, getstartline) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
        return (t_getstartline());
      }
      break;
    case 13:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD(0x48FDF6C5835C64CFLL, isinternal) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
        return (t_isinternal());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("reflectionfunction::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 1) return throw_wrong_arguments("reflectionfunction::__construct", count, 1, 1, 2);
        return (t___construct(a0), null);
      }
      break;
    case 32:
      HASH_GUARD(0x57D8DC34C9A03560LL, getnumberofparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
        return (t_getnumberofparameters());
      }
      break;
    case 33:
      HASH_GUARD(0x4D637DECDBFA6221LL, getnumberofrequiredparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 34:
      HASH_GUARD(0x33A6C2CFBDB05EE2LL, getclosure) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getclosure", 0, 1);
        return (t_getclosure());
      }
      break;
    case 36:
      HASH_GUARD(0x6A6B8BECAE7D4164LL, isuserdefined) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
        return (t_isuserdefined());
      }
      break;
    case 37:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
        return (t_getname());
      }
      break;
    case 40:
      HASH_GUARD(0x37FFB8F44A3329A8LL, getstaticvariables) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
        return (t_getstaticvariables());
      }
      HASH_GUARD(0x1A3AB3B0276D2668LL, returnsreference) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
        return (t_returnsreference());
      }
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 2) return throw_wrong_arguments("reflectionfunction::export", count, 2, 2, 1);
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 45:
      HASH_GUARD(0x3E62225132C2A32DLL, getparameters) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
        return (t_getparameters());
      }
      break;
    case 48:
      HASH_GUARD(0x6C19E85007BC4570LL, getendline) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
        return (t_getendline());
      }
      break;
    case 56:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
        return (t_getdoccomment());
      }
      break;
    default:
      break;
  }
  return c_reflectionfunctionabstract::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionfunction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionfunction
Variant c_reflectionfunction::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 2) return throw_wrong_arguments("reflectionfunction::export", count, 2, 2, 1);
        return (ti_export(c, params[0], params[1]));
      }
      break;
    default:
      break;
  }
  return c_reflectionfunctionabstract::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionfunction
Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 63) {
    case 2:
      HASH_GUARD(0x3FCE192CF6199942LL, invoke) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        if (count <= 0) return (t_invoke(count));
        return (t_invoke(count,vargs));
      }
      break;
    case 4:
      HASH_GUARD(0x3235AF57F23103C4LL, invokeargs) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionfunction::invokeargs", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_invokeargs(a0));
      }
      HASH_GUARD(0x39C1BB731CB1CB04LL, getstartline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstartline());
      }
      break;
    case 13:
      HASH_GUARD(0x1930CE336D39474DLL, getfilename) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 15:
      HASH_GUARD(0x48FDF6C5835C64CFLL, isinternal) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isinternal());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunction::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("reflectionfunction::__construct", count, 1, 1, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 32:
      HASH_GUARD(0x57D8DC34C9A03560LL, getnumberofparameters) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofparameters());
      }
      break;
    case 33:
      HASH_GUARD(0x4D637DECDBFA6221LL, getnumberofrequiredparameters) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getnumberofrequiredparameters());
      }
      break;
    case 34:
      HASH_GUARD(0x33A6C2CFBDB05EE2LL, getclosure) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getclosure", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclosure());
      }
      break;
    case 36:
      HASH_GUARD(0x6A6B8BECAE7D4164LL, isuserdefined) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isuserdefined());
      }
      break;
    case 37:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 40:
      HASH_GUARD(0x37FFB8F44A3329A8LL, getstaticvariables) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getstaticvariables());
      }
      HASH_GUARD(0x1A3AB3B0276D2668LL, returnsreference) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_returnsreference());
      }
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("reflectionfunction::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1));
      }
      break;
    case 45:
      HASH_GUARD(0x3E62225132C2A32DLL, getparameters) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getparameters());
      }
      break;
    case 48:
      HASH_GUARD(0x6C19E85007BC4570LL, getendline) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getendline());
      }
      break;
    case 56:
      HASH_GUARD(0x7C4F424FDA56ADF8LL, getdoccomment) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdoccomment());
      }
      break;
    default:
      break;
  }
  return c_reflectionfunctionabstract::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_reflectionfunction::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("reflectionfunction::export", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1));
      }
      break;
    default:
      break;
  }
  return c_reflectionfunctionabstract::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_reflectionfunction = {
  c_reflectionfunction::os_getInit,
  c_reflectionfunction::os_get,
  c_reflectionfunction::os_lval,
  c_reflectionfunction::os_invoke,
  c_reflectionfunction::os_constant,
};
void c_reflectionfunction::init() {
  c_reflectionfunctionabstract::init();
}
/* SRC: classes/reflection.php line 169 */
void c_reflectionfunction::t___construct(Variant v_name) {
  INSTANCE_METHOD_INJECTION(ReflectionFunction, ReflectionFunction::__construct);
  bool oldInCtor = gasInCtor(true);
  (m_info = x_hphp_get_function_info(toString(v_name)));
  if (empty(m_info)) {
    {
      {
        c_reflectionexception *tmp115 = NEWOBJ(c_reflectionexception)();
        throw_exception(p_reflectionexception(tmp115->create(StringBuffer().add("Function ", 9).add(toString(v_name)).add(" does not exist", 15).detach())));
      }
    }
  }
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/reflection.php line 176 */
String c_reflectionfunction::t___tostring() {
  INSTANCE_METHOD_INJECTION(ReflectionFunction, ReflectionFunction::__toString);
  return toString(null);
} /* function */
/* SRC: classes/reflection.php line 180 */
Variant c_reflectionfunction::ti_export(const char* cls, CVarRef v_name, CVarRef v_ret) {
  STATIC_METHOD_INJECTION(ReflectionFunction, ReflectionFunction::export);
  p_reflectionfunction v_obj;
  String v_str;

  {
    c_reflectionfunction *tmp116 = NEWOBJ(c_reflectionfunction)();
    p_reflectionfunction tmp117((p_reflectionfunction(tmp116->create(v_name))));
    (v_obj = tmp117);
  }
  (v_str = (toString(v_obj)));
  if (toBoolean(v_ret)) {
    {
      return v_str;
    }
  }
  print(v_str);
  return null;
} /* function */
/* SRC: classes/reflection.php line 189 */
Variant c_reflectionfunction::t_invoke(int num_args, Array args /* = Array() */) {
  INSTANCE_METHOD_INJECTION(ReflectionFunction, ReflectionFunction::invoke);
  Array v_args;

  {
    const Array &tmp118((func_get_args(num_args, Array(),args)));
    (v_args = tmp118);
  }
  {
    String tmp119((toString(m_info.rvalAt("name", 0x0BCDB293DC3DBDDCLL, true, true))));
    return x_hphp_invoke(tmp119, v_args);
  }
} /* function */
/* SRC: classes/reflection.php line 194 */
Variant c_reflectionfunction::t_invokeargs(CVarRef v_args) {
  INSTANCE_METHOD_INJECTION(ReflectionFunction, ReflectionFunction::invokeArgs);
  {
    String tmp120((toString(m_info.rvalAt("name", 0x0BCDB293DC3DBDDCLL, true, true))));
    return x_hphp_invoke(tmp120, toArray(x_array_values(v_args)));
  }
} /* function */
/* SRC: classes/reflection.php line 17 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionparameter
Variant c_reflectionparameter::os_getInit(const char *s, int64 hash) {
  DECLARE_SYSTEM_GLOBALS(g);
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 1:
      HASH_RETURN(0x3255DC7C4A035C47LL, 
                  null, info);
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionparameter
Variant c_reflectionparameter::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionparameter
Variant &c_reflectionparameter::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionparameter
void c_reflectionparameter::o_get(Array &props) const {
  if (isInitialized(m_info)) props.set("info", m_info.isReferenced() ? ref(m_info) : m_info, 0x3255DC7C4A035C47LL, true);
  c_ObjectData::o_get(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_get_reflectionparameter
Variant c_reflectionparameter::o_get(CStrRef prop, int64 phash, bool error /* = true */, const char *context /* = NULL */) {
  return c_reflectionparameter::o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionparameter
Variant c_reflectionparameter::o_getPublic(CStrRef s, int64 hash, bool error /* = true */) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 1) {
    case 1:
      HASH_RETURN_STRING(0x3255DC7C4A035C47LL, m_info,
                         info, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionparameter
Variant c_reflectionparameter::o_getPrivate(CStrRef s, int64 hash, bool error /* = true */) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_exists_reflectionparameter
bool c_reflectionparameter::o_exists(CStrRef prop, int64 phash, const char *context /* = NULL */) const {
  return c_reflectionparameter::o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionparameter
bool c_reflectionparameter::o_existsPublic(CStrRef s, int64 hash) const {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 1) {
    case 1:
      HASH_EXISTS_STRING(0x3255DC7C4A035C47LL, info, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionparameter
bool c_reflectionparameter::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_set_reflectionparameter
Variant c_reflectionparameter::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit /* = false */, const char *context /* = NULL */) {
  return c_reflectionparameter::o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionparameter
Variant c_reflectionparameter::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 1) {
    case 1:
      HASH_SET_STRING(0x3255DC7C4A035C47LL, m_info,
                      info, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionparameter
Variant c_reflectionparameter::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit /* = false */) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_lval_reflectionparameter
Variant& c_reflectionparameter::o_lval(CStrRef prop, int64 phash, const char *context /* = NULL */) {
  return c_reflectionparameter::o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionparameter
Variant& c_reflectionparameter::o_lvalPublic(CStrRef s, int64 hash) {
  if (hash < 0) hash = hash_string(s.data(), s.length());
  switch (hash & 1) {
    case 1:
      HASH_RETURN_STRING(0x3255DC7C4A035C47LL, m_info,
                         info, 4);
      break;
    default:
      break;
  }
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionparameter
Variant& c_reflectionparameter::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionparameter
Variant c_reflectionparameter::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_reflectionparameter
IMPLEMENT_CLASS(reflectionparameter)
c_reflectionparameter *c_reflectionparameter::create(Variant v_func, Variant v_param) {
  CountableHelper h(this);
  init();
  t___construct(v_func, v_param);
  return this;
}
ObjectData *c_reflectionparameter::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("reflectionparameter::__construct", count, 2, 2, 2);
    (t___construct(params[0], params[1]));
  }
  return this;
}
void c_reflectionparameter::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("reflectionparameter::__construct", count, 2, 2, 2);
  (t___construct(params[0], params[1]));
}
void c_reflectionparameter::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("reflectionparameter::__construct", count, 2, 2, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0, a1), null);
}
ObjectData *c_reflectionparameter::cloneImpl() {
  c_reflectionparameter *obj = NEW(c_reflectionparameter)();
  cloneSet(obj);
  return obj;
}
void c_reflectionparameter::cloneSet(c_reflectionparameter *clone) {
  clone->m_info = m_info.isReferenced() ? ref(m_info) : m_info;
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionparameter
Variant c_reflectionparameter::o_invoke(const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x6ED51288559D6063LL, getdeclaringclass) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::getdeclaringclass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::getname", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 3) return throw_wrong_arguments("reflectionparameter::export", count, 3, 3, 1);
        return (ti_export(o_getClassName(), params[0], params[1], params[2]));
      }
      HASH_GUARD(0x4044F1EEBF3BB8C8LL, getposition) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::getposition", 0, 1);
        return (t_getposition());
      }
      break;
    case 9:
      HASH_GUARD(0x4F51DA0B633E9909LL, getclass) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::getclass", 0, 1);
        return (t_getclass());
      }
      HASH_GUARD(0x24ED05F4504C4C09LL, allowsnull) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::allowsnull", 0, 1);
        return (t_allowsnull());
      }
      break;
    case 12:
      HASH_GUARD(0x27C482A6C7951E0CLL, getdefaultvalue) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::getdefaultvalue", 0, 1);
        return (t_getdefaultvalue());
      }
      break;
    case 17:
      HASH_GUARD(0x13E3F304BDD89FB1LL, ispassedbyreference) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::ispassedbyreference", 0, 1);
        return (t_ispassedbyreference());
      }
      break;
    case 18:
      HASH_GUARD(0x6E34805C91257C92LL, isdefaultvalueavailable) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::isdefaultvalueavailable", 0, 1);
        return (t_isdefaultvalueavailable());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 21:
      HASH_GUARD(0x2D6EF48BBAB22735LL, isoptional) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::isoptional", 0, 1);
        return (t_isoptional());
      }
      break;
    case 29:
      HASH_GUARD(0x5A9CE40C0F25871DLL, isarray) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::isarray", 0, 1);
        return (t_isarray());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 2) return throw_wrong_arguments("reflectionparameter::__construct", count, 2, 2, 2);
        return (t___construct(params[0], params[1]), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke(s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionparameter
Variant c_reflectionparameter::o_invoke_few_args(const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x6ED51288559D6063LL, getdeclaringclass) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::getdeclaringclass", 0, 1);
        return (t_getdeclaringclass());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::getname", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 3) return throw_wrong_arguments("reflectionparameter::export", count, 3, 3, 1);
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      HASH_GUARD(0x4044F1EEBF3BB8C8LL, getposition) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::getposition", 0, 1);
        return (t_getposition());
      }
      break;
    case 9:
      HASH_GUARD(0x4F51DA0B633E9909LL, getclass) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::getclass", 0, 1);
        return (t_getclass());
      }
      HASH_GUARD(0x24ED05F4504C4C09LL, allowsnull) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::allowsnull", 0, 1);
        return (t_allowsnull());
      }
      break;
    case 12:
      HASH_GUARD(0x27C482A6C7951E0CLL, getdefaultvalue) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::getdefaultvalue", 0, 1);
        return (t_getdefaultvalue());
      }
      break;
    case 17:
      HASH_GUARD(0x13E3F304BDD89FB1LL, ispassedbyreference) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::ispassedbyreference", 0, 1);
        return (t_ispassedbyreference());
      }
      break;
    case 18:
      HASH_GUARD(0x6E34805C91257C92LL, isdefaultvalueavailable) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::isdefaultvalueavailable", 0, 1);
        return (t_isdefaultvalueavailable());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 21:
      HASH_GUARD(0x2D6EF48BBAB22735LL, isoptional) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::isoptional", 0, 1);
        return (t_isoptional());
      }
      break;
    case 29:
      HASH_GUARD(0x5A9CE40C0F25871DLL, isarray) {
        if (count > 0) return throw_toomany_arguments("reflectionparameter::isarray", 0, 1);
        return (t_isarray());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        if (count != 2) return throw_wrong_arguments("reflectionparameter::__construct", count, 2, 2, 2);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_few_args(s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_reflectionparameter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionparameter
Variant c_reflectionparameter::os_invoke(const char *c, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        if (count != 3) return throw_wrong_arguments("reflectionparameter::export", count, 3, 3, 1);
        return (ti_export(c, params[0], params[1], params[2]));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke(c, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_reflectionparameter
Variant c_reflectionparameter::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD(0x6ED51288559D6063LL, getdeclaringclass) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionparameter::getdeclaringclass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdeclaringclass());
      }
      break;
    case 5:
      HASH_GUARD(0x23F51CDECC198965LL, getname) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionparameter::getname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("reflectionparameter::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(o_getClassName(), a0, a1, a2));
      }
      HASH_GUARD(0x4044F1EEBF3BB8C8LL, getposition) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionparameter::getposition", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getposition());
      }
      break;
    case 9:
      HASH_GUARD(0x4F51DA0B633E9909LL, getclass) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionparameter::getclass", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getclass());
      }
      HASH_GUARD(0x24ED05F4504C4C09LL, allowsnull) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionparameter::allowsnull", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_allowsnull());
      }
      break;
    case 12:
      HASH_GUARD(0x27C482A6C7951E0CLL, getdefaultvalue) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionparameter::getdefaultvalue", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getdefaultvalue());
      }
      break;
    case 17:
      HASH_GUARD(0x13E3F304BDD89FB1LL, ispassedbyreference) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionparameter::ispassedbyreference", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_ispassedbyreference());
      }
      break;
    case 18:
      HASH_GUARD(0x6E34805C91257C92LL, isdefaultvalueavailable) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionparameter::isdefaultvalueavailable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdefaultvalueavailable());
      }
      break;
    case 19:
      HASH_GUARD(0x642C2D2994B34A13LL, __tostring) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionparameter::__tostring", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 21:
      HASH_GUARD(0x2D6EF48BBAB22735LL, isoptional) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionparameter::isoptional", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isoptional());
      }
      break;
    case 29:
      HASH_GUARD(0x5A9CE40C0F25871DLL, isarray) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reflectionparameter::isarray", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isarray());
      }
      break;
    case 31:
      HASH_GUARD(0x0D31D0AC229C615FLL, __construct) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("reflectionparameter::__construct", count, 2, 2, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_reflectionparameter::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string_i(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD(0x0B5ABC58C98E70E8LL, export) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("reflectionparameter::export", count, 3, 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (ti_export(c, a0, a1, a2));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_reflectionparameter = {
  c_reflectionparameter::os_getInit,
  c_reflectionparameter::os_get,
  c_reflectionparameter::os_lval,
  c_reflectionparameter::os_invoke,
  c_reflectionparameter::os_constant,
};
void c_reflectionparameter::init() {
  m_info = null;
}
/* SRC: classes/reflection.php line 20 */
void c_reflectionparameter::t___construct(Variant v_func, Variant v_param) {
  INSTANCE_METHOD_INJECTION(ReflectionParameter, ReflectionParameter::__construct);
  bool oldInCtor = gasInCtor(true);
  Variant v_params;

  if (toBoolean(v_func) && toBoolean(v_param)) {
    {
      {
        Variant tmp121((v_func. BIND_CLASS_DOT o_invoke_few_args("getParameters", 0x3E62225132C2A32DLL, 0)));
        (v_params = tmp121);
      }
      (m_info = v_params.rvalAt(v_param, -1, true).o_get("info", 0x3255DC7C4A035C47LL));
    }
  }
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/reflection.php line 27 */
String c_reflectionparameter::t___tostring() {
  INSTANCE_METHOD_INJECTION(ReflectionParameter, ReflectionParameter::__toString);
  return toString(null);
} /* function */
/* SRC: classes/reflection.php line 31 */
Variant c_reflectionparameter::ti_export(const char* cls, CVarRef v_func, CVarRef v_param, CVarRef v_ret) {
  STATIC_METHOD_INJECTION(ReflectionParameter, ReflectionParameter::export);
  p_reflectionparameter v_obj;
  String v_str;

  {
    c_reflectionparameter *tmp122 = NEWOBJ(c_reflectionparameter)();
    p_reflectionparameter tmp123((p_reflectionparameter(tmp122->create(v_func, v_param))));
    (v_obj = tmp123);
  }
  (v_str = (toString(v_obj)));
  if (toBoolean(v_ret)) {
    {
      return v_str;
    }
  }
  print(v_str);
  return null;
} /* function */
/* SRC: classes/reflection.php line 40 */
Variant c_reflectionparameter::t_getname() {
  INSTANCE_METHOD_INJECTION(ReflectionParameter, ReflectionParameter::getName);
  return m_info.rvalAt("name", 0x0BCDB293DC3DBDDCLL, true, true);
} /* function */
/* SRC: classes/reflection.php line 44 */
Variant c_reflectionparameter::t_ispassedbyreference() {
  INSTANCE_METHOD_INJECTION(ReflectionParameter, ReflectionParameter::isPassedByReference);
  return m_info.rvalAt("ref", 0x0B1A6D25134ED5FALL, true, true);
} /* function */
/* SRC: classes/reflection.php line 48 */
Variant c_reflectionparameter::t_getdeclaringclass() {
  INSTANCE_METHOD_INJECTION(ReflectionParameter, ReflectionParameter::getDeclaringClass);
  if (empty(m_info, "class", 0x45397FE5C82CBD12LL, true)) {
    {
      return null;
    }
  }
  {
    c_reflectionclass *tmp124 = NEWOBJ(c_reflectionclass)();
    return p_reflectionclass(tmp124->create(m_info.rvalAt("class", 0x45397FE5C82CBD12LL, true, true)));
  }
} /* function */
/* SRC: classes/reflection.php line 55 */
Variant c_reflectionparameter::t_getclass() {
  INSTANCE_METHOD_INJECTION(ReflectionParameter, ReflectionParameter::getClass);
  if (empty(m_info, "type", 0x508FC7C8724B760ALL, true)) {
    {
      return null;
    }
  }
  {
    c_reflectionclass *tmp125 = NEWOBJ(c_reflectionclass)();
    return p_reflectionclass(tmp125->create(m_info.rvalAt("type", 0x508FC7C8724B760ALL, true, true)));
  }
} /* function */
/* SRC: classes/reflection.php line 62 */
bool c_reflectionparameter::t_isarray() {
  INSTANCE_METHOD_INJECTION(ReflectionParameter, ReflectionParameter::isArray);
  return equal(m_info.rvalAt("type", 0x508FC7C8724B760ALL, true, true), "array");
} /* function */
/* SRC: classes/reflection.php line 66 */
Variant c_reflectionparameter::t_allowsnull() {
  INSTANCE_METHOD_INJECTION(ReflectionParameter, ReflectionParameter::allowsNull);
  return m_info.rvalAt("nullable", 0x5E22F816EDD57A43LL, true, true);
} /* function */
/* SRC: classes/reflection.php line 70 */
bool c_reflectionparameter::t_isoptional() {
  INSTANCE_METHOD_INJECTION(ReflectionParameter, ReflectionParameter::isOptional);
  return x_array_key_exists("default", m_info);
} /* function */
/* SRC: classes/reflection.php line 74 */
bool c_reflectionparameter::t_isdefaultvalueavailable() {
  INSTANCE_METHOD_INJECTION(ReflectionParameter, ReflectionParameter::isDefaultValueAvailable);
  return isset(m_info, "default", 0x1575CB56409781E3LL, true);
} /* function */
/* SRC: classes/reflection.php line 78 */
Variant c_reflectionparameter::t_getdefaultvalue() {
  INSTANCE_METHOD_INJECTION(ReflectionParameter, ReflectionParameter::getDefaultValue);
  if (!(t_isoptional())) {
    {
      throw_exception(p_reflectionexception((NEWOBJ(c_reflectionexception)())->create("Parameter is not optional")));
    }
  }
  return m_info.rvalAt("default", 0x1575CB56409781E3LL, true, true);
} /* function */
/* SRC: classes/reflection.php line 85 */
Variant c_reflectionparameter::t_getposition() {
  INSTANCE_METHOD_INJECTION(ReflectionParameter, ReflectionParameter::getPosition);
  return m_info.rvalAt("index", 0x1C79FCB6D76A8068LL, true, true);
} /* function */
Object co_reflectionfunctionabstract(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_reflectionfunctionabstract)())->dynCreate(params, init));
}
Object co_reflectionobject(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_reflectionobject)())->dynCreate(params, init));
}
Object co_reflectionexception(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_reflectionexception)())->dynCreate(params, init));
}
Object co_reflectionclass(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_reflectionclass)())->dynCreate(params, init));
}
Object co_reflectionextension(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_reflectionextension)())->dynCreate(params, init));
}
Object co_reflectionmethod(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_reflectionmethod)())->dynCreate(params, init));
}
Object co_reflectionproperty(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_reflectionproperty)())->dynCreate(params, init));
}
Object co_reflectionfunction(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_reflectionfunction)())->dynCreate(params, init));
}
Object co_reflectionparameter(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_reflectionparameter)())->dynCreate(params, init));
}
Variant pm_php$classes$reflection_php(bool incOnce /* = false */, LVariableTable* variables /* = NULL */) {
  {
    DECLARE_SYSTEM_GLOBALS(g);
    bool &alreadyRun = g->run_pm_php$classes$reflection_php;
    if (alreadyRun) { if (incOnce) return true;}
    else alreadyRun = true;
    if (!variables) variables = g;
  }
  PSEUDOMAIN_INJECTION(run_init::classes/reflection.php);
  DECLARE_SYSTEM_GLOBALS(g);
  LVariableTable *gVariables __attribute__((__unused__)) = get_variable_table();
  return true;
} /* function */

///////////////////////////////////////////////////////////////////////////////
}
